<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Identity Management</title>
  
    <section>
      <title>Overview</title>
      
      <para>
        PicketLink's Identity Management (IDM) features provide a rich and extensible API for managing the users, groups and roles of
        your applications and services. The <code>org.picketlink.idm.IdentityManager</code> interface declares all the methods required to
        create, update and delete Identity objects and create relationships between them such as group and role memberships.
      </para>
      
      <para>
        Interaction with the backend store that provides the persistent identity state is performed by configuring one or more
        <code>IdentityStore</code>s.  PicketLink provides a few built-in <code>IdentityStore</code> implementations for storing
        identity state in a database, file system or LDAP directory server, and it is possible to provide your own custom
        implementation to support storing your application's identity data in other backends, or extend the built-in implementations
        to override their default behaviour.
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/identity_manager_stores.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/identity_manager_stores.png" align="center"/>
        </imageobject>
      </mediaobject> 
      
      <para>
        Before PicketLink IDM can be used, it must first be configured.  See the configuration section below for details on
        how to configure IDM for both Java EE and Java SE environments.
      </para>
    </section>
    
    <section>
      <title>Identity Model</title>
      
      <para>
        PicketLink's identity model consists of a number of core interfaces that define the fundamental identity types
        upon which much of the Identity Management API is based.  The following class diagram shows the classes and interfaces
        in the <code>org.picketlink.idm.model</code> package that form the base identity model.
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/identitymodel.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/identitymodel.png" align="center"/>
        </imageobject>
      </mediaobject>      
      
      <itemizedlist>
        <listitem>
          <para>
            <code>AttributedType</code> is the base interface for the identity model.  It declares a number of methods for
            managing a set of attribute values, plus <code>getId()</code> and <code>setId()</code> methods for setting a 
            unique UUID value.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Attribute</code> is used to represent an attribute value.  An attribute has a name and a (generically typed) value,
            and may be marked as read-only.  Attribute values that are expensive to load (such as large binary data) may be lazy-loaded; 
            the <code>isLoaded()</code> method may be used to determine whether the Attribute has been loaded or not.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>IdentityType</code> is the base interface for Identity objects.  It declares properties that indicate whether the
            identity object is enabled or not, optional created and expiry dates, plus methods to read and set the owning 
            <code>Partition</code>.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Agent</code> represents a unique entity that may access the services secured by PicketLink.  In contrast to a user
            which represents a human, <code>Agent</code> is intended to represent a third party non-human (i.e. machine to machine) 
            process that may authenticate and interact with your application or services.  It declares methods for reading and setting
            the <code>Agent</code>'s login name.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>User</code> represents a human user that accesses your application and services.  In addition to the login name
            property defined by its parent interface <code>Agent</code>, the <code>User</code> interface declares a number of other
            methods for managing the user's first name, last name and e-mail address.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Group</code> is used to manage collections of identity types.  Each <code>Group</code> has a name and an optional
            parent group.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Role</code> is used in various relationship types to designate authority to another identity type to perform
            various operations within an application.  For example, a forum application may define a role called 
            <emphasis>moderator</emphasis> which may be assigned to one or more <code>User</code>s or <code>Group</code>s to indicate 
            that they are authorized to perform moderator functions.
          </para>
        </listitem>
      
      </itemizedlist>
      
    </section>
          
    <section>
      <title>Configuration</title>
    
        <section>
          <title>Architectural Overview</title>
          
          <para>
            Configuration in PicketLink is in essence quite simple; an <code>IdentityConfiguration</code> object must first 
            be created to hold the PicketLink configuration options.  Once all configuration options have been set, the 
            <code>buildIdentityManagerFactory()</code> method is used to create an <code>IdentityManagerFactory</code> instance.
            The <code>IdentityManagerFactory</code> can then be used to create <code>IdentityManager</code> instances 
            via the <code>createIdentityManager()</code> method.  
          </para>          
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/architecture.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/architecture.png" align="center"/>
            </imageobject>
          </mediaobject>
          
          <para>
            Each <code>IdentityManager</code> instance has its own <emphasis>security context</emphasis>, represented by
            the <code>SecurityContext</code> class.  The security context contains temporary state which is maintained 
            for one or more identity management operations within the scope of a single realm or tier.  The 
            <code>IdentityManager</code> (and its associated <code>SecurityContext</code>) is typically modelled as a
            request-scoped object (for environments which support such a paradigm, such as a servlet container), or alternatively
            as an actor within the scope of a transaction.  In the latter case, the underlying resources being 
            utilised by the configured identity stores (such as a JPA <code>EntityManager</code>) would participate in 
            the active transaction, and changes made as a result of any identity management operations would either be 
            committed or rolled back as appropriate for the logic of the encapsulating business method.
          </para>
            
          <para>
            The following sections describe various ways that configuration may be performed in different environments.
          </para>
          
        </section>
      
      <section>
        <title>Programmatic Configuration</title>
      
        <para>
          Configuration for Identity Management can be defined programmatically by creating an instance of the
          <code>org.picketlink.config.IdentityConfiguration</code> class.  This class provides an API that allows one or 
          more identity stores to be configured (along with a number of other options) which are then used to 
          create an <code>IdentityManagerFactory</code>.  An <code>IdentityConfiguration</code> can be created via its
          default constructor like so:
        </para>
        
        <programlisting><![CDATA[  IdentityConfiguration config = new IdentityConfiguration();]]></programlisting>
        
        <para>
          Let's start by looking at the methods we use to configure the identity stores.
        </para>
      
        <programlisting language="JAVA"><![CDATA[public class IdentityConfiguration {

    public List<IdentityStoreConfiguration> getConfiguredStores() {
        return this.configuredStores;
    }
  
    public void addStoreConfiguration(IdentityStoreConfiguration config) {
        this.configuredStores.add(config);
    }
}]]></programlisting>

      </section>
      
      <section>
        <title>Identity Store Configurations</title>
      
        <para>
          For each of the built-in <code>IdentityStore</code> implementations there is a corresponding <code>IdentityStoreConfiguration</code> 
          implementation - the following sections describe each of these in more detail.
        </para>
        
        <section>
          <title>JPAIdentityStoreConfiguration</title>
          
          <para>
            The JPA identity store uses a relational database to store identity state.  The configuration for this identity store
            provides control over which entity beans are used to store identity data, and how their fields should be used to store
            various identity-related state.
          </para>
          
          <section>
            <title>Configuring an EntityManager</title>
            
            <para>
              Before the JPA identity store can be used, it must be provided with an <code>EntityManager</code> so that it can
              connect to a database.  
            </para>
          </section>
          
          <section>
            <title>Configuring the Identity class</title>
            
            <para>
              The Identity class is the entity bean that is used to store the record for users, roles and groups. It should
              be annotated with <code>@IDMEntity(EntityType.IDENTITY_TYPE)</code> and declare the following field values:
            </para>
            
            <note>
              <para>
                The Property Type listed in the tables below refer to the values defined by the 
                <code>org.picketlink.idm.jpa.annotations.PropertyType</code> enum, and should be specified within the
                <code>@IDMProperty</code> annotation which should be placed on each of the entity properties; for example,
                the <code>IDENTITY_ID</code> property type should be specified like so:
              </para>
              
              <programlisting language="JAVA"><![CDATA[  @IDMProperty(PropertyType.IDENTITY_ID) private String id;]]></programlisting>
            </note>
            
            <table>
              <title>Identity class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>ID</entry>
                    <entry><code>IDENTITY_ID</code></entry>
                    <entry>The unique identifier value for the identity (can also double as the primary key value)</entry>
                  </row>
                  <row>
                    <entry>Discriminator</entry>
                    <entry><code>IDENTITY_DISCRIMINATOR</code></entry>
                    <entry>Indicates the identity type (i.e. user, agent, group or role) of the identity.</entry>
                  </row>
                  <row>
                    <entry>Partition</entry>
                    <entry><code>IDENTITY_PARTITION</code></entry>
                    <entry>The partition (realm or tier) that the identity belongs to</entry>
                  </row>
                  <row>
                    <entry>Login name</entry>
                    <entry><code>AGENT_LOGIN_NAME</code></entry>
                    <entry>The login name for agent and user identities (for other identity types this will be null)</entry>
                  </row>
                  <row>
                    <entry>Name</entry>
                    <entry><code>IDENTITY_NAME</code></entry>
                    <entry>The name for group and role identities (for other identity types this will be null)</entry>
                  </row>
                  <row>
                    <entry>First Name</entry>
                    <entry><code>USER_FIRST_NAME</code></entry>
                    <entry>The first name of a user identity</entry>
                  </row>
                  <row>
                    <entry>Last Name</entry>
                    <entry><code>USER_LAST_NAME</code></entry>
                    <entry>The last name of a user identity</entry>
                  </row>
                  <row>
                    <entry>E-mail</entry>
                    <entry><code>USER_EMAIL</code></entry>
                    <entry>The primary e-mail address of a user identity</entry>
                  </row>
                  <row>
                    <entry>Enabled</entry>
                    <entry><code>IDENTITY_ENABLED</code></entry>
                    <entry>Indicates whether the identity is enabled</entry>
                  </row>
                  <row>
                    <entry>Creation date</entry>
                    <entry><code>IDENTITY_CREATION_DATE</code></entry>
                    <entry>The creation date of the identity</entry>
                  </row>
                  <row>
                    <entry>Expiry date</entry>
                    <entry><code>IDENTITY_EXPIRY_DATE</code></entry>
                    <entry>The expiry date of the identity</entry>
                  </row>
                  <row>
                    <entry>Group parent</entry>
                    <entry><code>GROUP_PARENT</code></entry>
                    <entry>The parent group (only used for Group identity types, for other types will be null)</entry>
                  </row>
                  <row>
                    <entry>Group path</entry>
                    <entry><code>GROUP_PATH</code></entry>
                    <entry>Represents the full group path (for Group identity types only)</entry>
                  </row>
                </tbody>
              </tgroup>
              
            </table>
            
            <para>
              The following code shows an example of an entity class configured to store Identity instances:
            </para>
            
            <example>
              <title>Example Identity class</title>
              <programlisting language="JAVA"><![CDATA[@IDMEntity(EntityType.IDENTITY_TYPE)
@Entity
public class IdentityObject implements Serializable {

    @IDMProperty(PropertyType.IDENTITY_DISCRIMINATOR)
    private String discriminator;

    @ManyToOne
    @IDMProperty (PropertyType.IDENTITY_PARTITION)
    private PartitionObject partition;

    @IDMProperty(PropertyType.IDENTITY_ID)
    @Id
    private String id;

    @IDMProperty(PropertyType.AGENT_LOGIN_NAME)
    private String loginName;

    @IDMProperty(PropertyType.IDENTITY_NAME)
    private String name;

    @IDMProperty(PropertyType.USER_FIRST_NAME)
    private String firstName;

    @IDMProperty(PropertyType.USER_LAST_NAME)
    private String lastName;

    @IDMProperty(PropertyType.USER_EMAIL)
    private String email;

    @IDMProperty(PropertyType.IDENTITY_ENABLED)
    private boolean enabled;

    @IDMProperty(PropertyType.IDENTITY_CREATION_DATE)
    @Temporal(TemporalType.TIMESTAMP)
    private Date creationDate;

    @IDMProperty(PropertyType.IDENTITY_EXPIRY_DATE)
    @Temporal(TemporalType.TIMESTAMP)
    private Date expiryDate;

    @ManyToOne
    @IDMProperty(PropertyType.GROUP_PARENT)
    private IdentityObject parent;

    @IDMProperty (PropertyType.GROUP_PATH)
    private String groupPath;              
    
    // getters and setters
}]]></programlisting>
            </example>
            
          </section>
          
          <section>
            <title>Configuring the Attribute class</title>
            
            <para>
              The Attribute class is used to store Identity attributes, and should be annotated with
              <code>@IDMEntity(EntityType.IDENTITY_ATTRIBUTE)</code>
            </para>
            
            <table>
              <title>Attribute class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Identity</entry>
                    <entry><code>ATTRIBUTE_IDENTITY</code></entry>
                    <entry>The identity object to which the attribute value belongs</entry>
                  </row>
                  <row>
                    <entry>Name</entry>
                    <entry><code>ATTRIBUTE_NAME</code></entry>
                    <entry>The name of the attribute</entry>
                  </row>
                  <row>
                    <entry>Value</entry>
                    <entry><code>ATTRIBUTE_VALUE</code></entry>
                    <entry>The value of the attribute</entry>
                  </row>
                  <row>
                    <entry>Type</entry>
                    <entry><code>ATTRIBUTE_TYPE</code></entry>
                    <entry>The fully qualified classname of the attribute value class</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>          
            
            <example>
              <title>Example Attribute class</title>
              <programlisting language="JAVA"><![CDATA[@Entity
@IDMEntity(EntityType.IDENTITY_ATTRIBUTE)
public class IdentityAttribute implements Serializable {
    @Id @GeneratedValue private Long id;

    @ManyToOne @JoinColumn
    @IDMProperty (PropertyType.ATTRIBUTE_IDENTITY)
    private IdentityObject identityObject;

    @IDMProperty(PropertyType.ATTRIBUTE_NAME)
    private String name;

    @IDMProperty(PropertyType.ATTRIBUTE_VALUE)
    private String value;

    @IDMProperty(PropertyType.ATTRIBUTE_TYPE)
    private String type;
    
    // getters and setters
}]]></programlisting>
            </example>
            
          </section>
          
          <section>
            <title>Configuring the Credential class</title>
            
            <para>
              The credential entity is used to store user credentials such as passwords and certificates, and should be annotated
              with <code>@IDMEntity(EntityType.IDENTITY_CREDENTIAL)</code>.
            </para>
            
            <table>
              <title>Credential class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Type</entry>
                    <entry><code>CREDENTIAL_TYPE</code></entry>
                    <entry>The fully qualified classname of the credential type</entry>
                  </row>
                  <row>
                    <entry>Value</entry>
                    <entry><code>CREDENTIAL_VALUE</code></entry>
                    <entry>The value of the credential</entry>
                  </row>
                  <row>
                    <entry>Effective Date</entry>
                    <entry><code>CREDENTIAL_EFFECTIVE_DATE</code></entry>
                    <entry>The effective date of the credential</entry>
                  </row>
                  <row>
                    <entry>Expiry Date</entry>
                    <entry><code>CREDENTIAL_EXPIRY_DATE</code></entry>
                    <entry>The expiry date of the credential</entry>
                  </row>
                  <row>
                    <entry>Identity</entry>
                    <entry><code>CREDENTIAL_IDENTITY</code></entry>
                    <entry>The identity to which the credential belongs</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Credential class</title>
              <programlisting language="JAVA"><![CDATA[@Entity
@IDMEntity(EntityType.IDENTITY_CREDENTIAL)
public class IdentityCredential implements Serializable {
    @Id @GeneratedValue private Long id;

    @IDMProperty (PropertyType.CREDENTIAL_TYPE)
    private String type;

    @IDMProperty (PropertyType.CREDENTIAL_VALUE)
    private String credential;

    @IDMProperty (PropertyType.CREDENTIAL_EFFECTIVE_DATE)
    @Temporal (TemporalType.TIMESTAMP)
    private Date effectiveDate;

    @IDMProperty (PropertyType.CREDENTIAL_EXPIRY_DATE)
    @Temporal (TemporalType.TIMESTAMP)
    private Date expiryDate;

    @IDMProperty (PropertyType.CREDENTIAL_IDENTITY)
    @ManyToOne
    private IdentityObject identityType;
    
    // getters and setters
}]]></programlisting>
            </example>
              
          </section>
          
          <section>
            <title>Configuring the Credential Attribute class</title>
            
            <para>
              The Credential Attribute class is used to store arbitrary attribute values relating to the credential.  It
              should be annotated with <code>@IDMEntity(EntityType.CREDENTIAL_ATTRIBUTE)</code>.
            </para>
            
            <table>
              <title>Credential Attribute class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Credential Object</entry>
                    <entry><code>CREDENTIAL_ATTRIBUTE_CREDENTIAL</code></entry>
                    <entry>The credential to which this attribute belongs</entry>
                  </row>
                  <row>
                    <entry>Attribute Name</entry>
                    <entry><code>CREDENTIAL_ATTRIBUTE_NAME</code></entry>
                    <entry>The name of the attribute</entry>
                  </row>
                  <row>
                    <entry>Attribute Value</entry>
                    <entry><code>CREDENTIAL_ATTRIBUTE_VALUE</code></entry>
                    <entry>The value of the attribute</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Credential Attribute class</title>
              <programlisting language="JAVA"><![CDATA[@Entity
@IDMEntity(EntityType.CREDENTIAL_ATTRIBUTE)
public class IdentityCredentialAttribute implements Serializable {
    @Id @GeneratedValue private Long id;

    @ManyToOne @JoinColumn
    @IDMProperty (PropertyType.CREDENTIAL_ATTRIBUTE_CREDENTIAL)
    private IdentityCredential credential;

    @IDMProperty(PropertyType.CREDENTIAL_ATTRIBUTE_NAME)
    private String name;

    @IDMProperty(PropertyType.CREDENTIAL_ATTRIBUTE_VALUE)
    private String value;
    
    // getters and setters
}]]></programlisting>
            </example>
            
          </section>
          
          <section>
            <title>Configuring the Relationship class</title>
            
            <para>
              Relationships are used to define typed associations between two or more identities.  The Relationship class should
              be annotated with <code>@IDMEntity(EntityType.RELATIONSHIP)</code>.
            </para>
            
            <table>
              <title>Relationship class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Identifier</entry>
                    <entry><code>RELATIONSHIP_ID</code></entry>
                    <entry>Unique identifier that represents the specific relationship (can also double as the primary key)</entry>
                  </row>
                  <row>
                    <entry>Relationship Class</entry>
                    <entry><code>RELATIONSHIP_CLASS</code></entry>
                    <entry>The fully qualified class name of the relationship type</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Relationship class</title>
              <programlisting language="JAVA"><![CDATA[@IDMEntity(EntityType.RELATIONSHIP)
@Entity
public class Relationship implements Serializable {
    @Id @IDMProperty(PropertyType.RELATIONSHIP_ID)
    private String id;

    @IDMProperty(PropertyType.RELATIONSHIP_CLASS)
    private String type;

    // getters and setters
}]]></programlisting>
            </example>
          </section>
          
          <section>
            <title>Configuring the Relationship Identity class</title>
            
            <para>
              The Relationship Identity class is used to store the specific identities that participate in a relationship. It
              should be annotated with <code>@IDMEntity(EntityType.RELATIONSHIP_IDENTITY)</code>.
            </para>
            
            <table>
              <title>Relationship Identity class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Relationship Descriptor</entry>
                    <entry><code>RELATIONSHIP_DESCRIPTOR</code></entry>
                    <entry>Denotes the role of the identity in the relationship</entry>
                  </row>
                  <row>
                    <entry>Relationship Identity</entry>
                    <entry><code>RELATIONSHIP_IDENTITY</code></entry>
                    <entry>The identity that is participating in the relationship</entry>
                  </row>
                  <row>
                    <entry>Relationship</entry>
                    <entry><code>RELATIONSHIP_IDENTITY_RELATIONSHIP</code></entry>
                    <entry>The relationship to which the relationship identity belongs</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Relationship Identity class</title>
              <programlisting language="JAVA"><![CDATA[@IDMEntity(EntityType.RELATIONSHIP_IDENTITY)
@Entity
public class RelationshipIdentityObject implements Serializable {
    @Id @GeneratedValue private Long id;

    @IDMProperty(PropertyType.RELATIONSHIP_DESCRIPTOR)
    private String descriptor;

    @IDMProperty(PropertyType.RELATIONSHIP_IDENTITY)
    @ManyToOne
    private IdentityObject identityObject;

    @IDMProperty(PropertyType.RELATIONSHIP_IDENTITY_RELATIONSHIP)
    @ManyToOne
    private RelationshipObject relationshipObject;
    
    // getters and setters
}]]></programlisting>
            </example>
          </section>
          
          <section>
            <title>Configuring the Relationship Attribute class</title>
            
            <para>
              The Relationship Attribute class is used to store arbitrary attribute values that relate to a specific relationship.
              It should be annotated with <code>@IDMEntity(EntityType.RELATIONSHIP_ATTRIBUTE)</code>.
            </para>
            
            <table>
              <title>Relationship Attribute class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>Relationship</entry>
                    <entry><code>RELATIONSHIP_ATTRIBUTE_RELATIONSHIP</code></entry>
                    <entry>The relationship to which the attribute belongs</entry>
                  </row>
                  <row>
                    <entry>Attribute Name</entry>
                    <entry><code>RELATIONSHIP_ATTRIBUTE_NAME</code></entry>
                    <entry>The name of the attribute</entry>
                  </row>
                  <row>
                    <entry>Attribute value</entry>
                    <entry><code>RELATIONSHIP_ATTRIBUTE_VALUE</code></entry>
                    <entry>The value of the attribute</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Relationship Attribute class</title>

              <programlisting language="JAVA"><![CDATA[@Entity
@IDMEntity(EntityType.RELATIONSHIP_ATTRIBUTE)
public class RelationshipObjectAttribute implements Serializable {
    @Id @GeneratedValue private Long id;

    @ManyToOne @JoinColumn
    @IDMProperty(PropertyType.RELATIONSHIP_ATTRIBUTE_RELATIONSHIP)
    private Relationship relationship;

    @IDMProperty(PropertyType.RELATIONSHIP_ATTRIBUTE_NAME)
    private String name;

    @IDMProperty(PropertyType.RELATIONSHIP_ATTRIBUTE_VALUE)
    private String value;
    
    // getters and setters
}]]></programlisting>
            </example>
          </section>
          
          <section>
            <title>Configuring the Partition class</title>
            
            <para>
              The Partition class is used to store information about partitions, i.e. Realms and Tiers.  It should be 
              annotated with <code>@IDMEntity(EntityType.PARTITION)</code>.
            </para>
            
            <table>
              <title>Partition class fields</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Property</entry>
                    <entry>Property Type</entry>
                    <entry>Description</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>ID</entry>
                    <entry><code>PARTITION_ID</code></entry>
                    <entry>The unique identifier value for the partition</entry>
                  </row>
                  <row>
                    <entry>Name</entry>
                    <entry><code>PARTITION_NAME</code></entry>
                    <entry>The name of the partition</entry>
                  </row>
                  <row>
                    <entry>Type</entry>
                    <entry><code>PARTITION_TYPE</code></entry>
                    <entry>The type of partition, either Realm or Tier</entry>
                  </row>
                  <row>
                    <entry>Parent</entry>
                    <entry><code>PARTITION_PARENT</code></entry>
                    <entry>The parent partition (only used for Tiers)</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <example>
              <title>Example Partition class</title>
              <programlisting language="JAVA"><![CDATA[@Entity
@IDMEntity(EntityType.PARTITION)
public class PartitionObject implements Serializable {
    @Id @IDMProperty(PropertyType.PARTITION_ID)
    private String id;

    @IDMProperty(PropertyType.PARTITION_NAME)
    private String name;

    @IDMProperty(PropertyType.PARTITION_TYPE)
    private String type;

    @ManyToOne @IDMProperty(PropertyType.PARTITION_PARENT)
    private PartitionObject parent;
    
    // getters and setters
}]]></programlisting>
            </example>
          </section>
                 
        </section>
        
        <section>
          <title>LDAPIdentityStoreConfiguration</title>
          
          <para>
            The LDAP identity store allows an LDAP directory server to be used to provide identity state. You can use this store in read-only or write-read mode, depending on your permissions on the server.
          </para>
          
          <section>
            <title>Configuration</title>
            
            <para>
              The LDAP identity store can be configured by providing the following configuration:
			</para>
			
            <programlisting language="JAVA"><![CDATA[LDAPIdentityStoreConfiguration ldapStoreConfig = new LDAPIdentityStoreConfiguration();

ldapStoreConfig
	.setBaseDN(BASE_DN)
	.setBindDN(BIND_DN)
    .setBindCredential(BIND_CREDENTIAL)
    .setLdapURL(LDAP_URL)
    .setUserDNSuffix(USER_DN_SUFFIX)
    .setRoleDNSuffix(ROLES_DN_SUFFIX)
    .setAgentDNSuffix(AGENT_DN_SUFFIX)
    .setGroupDNSuffix(GROUP_DN_SUFFIX)
    .addRealm(Realm.DEFAULT_REALM)
    .supportAllFeatures();]]></programlisting>
			
			<para>
				The following table describes all configuration options:
			</para>
			
			<table>
              <title>LDAP Configuration Options</title>
              
              <tgroup cols="3" align="left">
                <thead>
                  <row>
                    <entry>Option</entry>
                    <entry>Description</entry>
                    <entry>Required</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry><code>setBaseDN</code></entry>
                    <entry>Sets the fixed DN of the context from where identity types are stored.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setBindDN</code></entry>
                    <entry>Sets the the DN used to bind against the ldap server. If you want to perform write operations the DN must have permissions on the agent,user,role and group contexts.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setBindCredential</code></entry>
                    <entry>Sets the password for the bindDN.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setLdapURL</code></entry>
                    <entry>Sets the url that should be used to connect to the server. Eg.: <![CDATA[ldap://<<server>>:389]]>.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setUserDNSuffix</code></entry>
                    <entry>Sets the fixed DN of the context where users should be read/stored from.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setAgentDNSuffix</code></entry>
                    <entry>Sets the fixed DN of the context where agents should be read/stored from. If not provided, will be used the context provided by the <code>setUserDNSuffix</code></entry>
                    <entry>No</entry>
                  </row>
                  <row>
                    <entry><code>setRoleDNSuffix</code></entry>
                    <entry>Sets the fixed DN of the context where roles should be read/stored from.</entry>
                    <entry>Yes</entry>
                  </row>
                  <row>
                    <entry><code>setGroupDNSuffix</code></entry>
                    <entry>Sets the fixed DN of the context where groups should be read/stored from.</entry>
                    <entry>Yes</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            
            <section>
            	<title>Mapping Groups to different contexts</title>
            	
            	<para>
            		Sometimes may be useful to map a specific group to a specific context or DN. By default, all groups are stored and read from the DN provided by the <code>setGroupDNSuffix</code> method, which means that you can not have groups with the same name.
            	</para>

            	<para>
            		The following configuration maps the group with path <emphasis>/QA Group</emphasis> to <emphasis>ou=QA,dc=jboss,dc=org</emphasis> 
            	</para>
            	
            	<programlisting language="JAVA"><![CDATA[LDAPIdentityStoreConfiguration ldapStoreConfig = new LDAPIdentityStoreConfiguration();

ldapStoreConfig
    .addGroupMapping("/QA Group", "ou=QA,dc=jboss,dc=org");]]></programlisting>
				
				<para>
					With this configuration you can have groups with the same name, but with different paths.
				</para>

            	<programlisting language="JAVA"><![CDATA[IdentityManager identityManager = getIdentityManager();
        
Group managerGroup = identityManager.add(new SimpleGroup("managers")); // group's path is /manager 
                
Group qaGroup = identityManager.getGroup("QA Group");        
        
// the QA Group was mapped to a different DN.
Group qaManagerGroup = identityManager.add(new SimpleGroup("managers", qaGroup)); // group's path is /QA Group/managers]]></programlisting>
				    
            </section>			
          </section>
        </section>
        
        <section>
          <title>FileIdentityStoreConfiguration</title>
          
          <para>
		  	This identity store uses the file system to persist identity state.  The configuration for this 
            identity store provides control over where to store identity data and if the state should be preserved between initializatons. 
          </para>

          <section>
            <title>Filesystem Structure</title>
            
            <para>
			 Identity data is stored in the filesystem using the following structure:
            </para>
            
		 	<programlisting language="xml"><![CDATA[${WORKING_DIR}/
	pl-idm-partitions.db
	pl-idm-relationships.db
	<<partition_name_directory>>
		pl-idm.agents.db
		pl-idm.roles.db
		pl-idm.groups.db
		pl-idm.credentials.db
	<<another_partition_directory>>
		...]]></programlisting>
		
			<para>
				By default, files are stored in the <emphasis>${java.io.tmpdir}/pl-idm</emphasis> directory. For each partition there is a corresponding directory where agents, roles groups and credentials are stored in specific files. 
			</para>
			
		  </section>
		  		
          <section>
            <title>Configuration</title>
            
            <para>
              The file identity store can be easily configured by providing the following configuration:
			</para>
			              
            <programlisting language="JAVA"><![CDATA[FileIdentityStoreConfiguration fileStoreConfig = new FileIdentityStoreConfiguration();

fileStoreConfig
   	.addRealm(Realm.DEFAULT_REALM)
   	.supportAllFeatures();]]></programlisting>

          	<section>
            	<title>Preserving State Between Initializations</title>
            	
            	<para>
            		By default, during the initialization, the working directory is re-created. If you want to preserve state between initializations you should use the following configuration:
            	</para>
            	
            	<programlisting language="JAVA"><![CDATA[FileIdentityStoreConfiguration fileStoreConfig = new FileIdentityStoreConfiguration();
				
fileStoreConfig
    .setAlwaysCreateFiles(false) // preserve data
   	.addRealm(Realm.DEFAULT_REALM)
   	.supportAllFeatures();]]></programlisting>
			</section>
			
			<section>
            	<title>Changing the Working Directory</title>
            	
            	<para>
				 If you want to change the working directory, where files are stored, you can use the following configuration:            		
            	</para>
            	
              	<programlisting language="JAVA"><![CDATA[FileIdentityStoreConfiguration fileStoreConfig = new FileIdentityStoreConfiguration();
				
fileStoreConfig
    .setWorkingDir("/tmp/pl-idm") // changes the working directory
   	.addRealm(Realm.DEFAULT_REALM)
   	.supportAllFeatures();]]></programlisting>
       	
			</section>            
          </section>          
        </section>      
      </section>
      
      <section>
        <title>Java EE Environments</title>
        
        <para>
          In Java EE 6.0 and higher environments, basic configuration is performed automatically with a set of sensible defaults.
          During application deployment, PicketLink will scan all deployed entity beans for any beans annotated with 
          <code>@IDMEntity</code>, and if found will use a configuration based on the <code>JPAIdentityStore</code>.
          If no entity beans have been configured for identity management and no other configuration is provided,
          a file-based identity store will be automatically configured to provide basic identity management features 
          backed by the file system.
        </para>

      </section>
      
    </section>
    
    <section>
      <title>Using the IdentityManager</title>
      
      <para>
        The <code>org.picketlink.idm.IdentityManager</code> interface provides access to the bulk of the IDM features supported by PicketLink.
        To get access to the <code>IdentityManager</code> depends on which environment you are using. The following two
        sections describe how to access the <code>IdentityManager</code> in both Java EE and Java SE environments.
      </para>
      
      <section>
        <title>Accessing the <code>IdentityManager</code> in Java EE</title>
        
        <para>
          In a Java EE environment, the PicketLink Core module provides a producer method for <code>IdentityManager</code>, 
          so getting a reference to it is as simply as injecting it into your beans:
        </para>
      
        <programlisting language="JAVA"><![CDATA[@Inject IdentityManager identityManager;]]></programlisting>
  
      </section>
      
      <section>
        <title>Accessing the <code>IdentityManager</code> in Java SE</title>
        
        <para>
        
        </para>
      </section>
    </section>
    
    <section>
      <title>Managing Users, Groups and Roles</title>
      
      <para>
        PicketLink IDM provides a number of basic implementations of the identity model interfaces for convenience, in the
        <code>org.picketlink.idm.model</code> package.  The following sections provide examples that show these 
        implementations in action.
      </para>
  
      <section>
        <title>Managing Users</title>
        
        <para>
          The following code example demonstrates how to create a new user with the following properties:
        </para>
        
        <itemizedlist>
          <listitem>Login name - <emphasis>jsmith</emphasis></listitem>
          <listitem>First name - <emphasis>John</emphasis></listitem>
          <listitem>Last name - <emphasis>Smith</emphasis></listitem>
          <listitem>E-mail - <emphasis>jsmith@acme.com</emphasis></listitem>
        </itemizedlist> 
        
        <programlisting language="JAVA"><![CDATA[  User user = new SimpleUser("jsmith");
  user.setFirstName("John");
  user.setLastName("Smith");
  user.setEmail("jsmith@acme.com");
  identityManager.add(user);]]></programlisting>
  
        <para>
          Once the <code>User</code> is created, it's possible to look it up using its login name:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");]]></programlisting>
        
        <para>
          User properties can also be modified after the User has already been created.  The following example demonstrates how
          to change the e-mail address of the user we created above:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");
  user.setEmail("john@smith.com");
  identityManager.update(user);]]></programlisting>
  
        <para>
          Users may also be deleted.  The following example demonstrates how to delete the user previously created:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");
  identityManager.remove("jsmith");]]></programlisting>
        
      </section>
      
      <section>
        <title>Managing Groups</title>
        
        <para>
          The following example demonstrates how to create a new group called <emphasis>employees</emphasis>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = new SimpleGroup("employees");]]></programlisting>
        
        <para>
          It is also possible to assign a parent group when creating a group.  The following example demonstrates how
          to create a new group called <emphasis>managers</emphasis>, using the <emphasis>employees</emphasis> group 
          created in the previous example as the parent group:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group managers = new SimpleGroup("managers", employees);]]></programlisting>
        
        <para>
          To lookup an existing <code>Group</code>, the <code>getGroup()</code> method may be used.  If the group name
          is unique, it can be passed as a single parameter:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");]]></programlisting>
        
        <para>
          If the group name is not unique, the parent group must be passed as the second parameter (although it can still be
          provided if the group name is unique):
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group managers = identityManager.getGroup("managers", employees);]]></programlisting>
        
        <para>
          It is also possible to modify a <code>Group</code>'s name and other properties (besides its parent) after it has
          been created.  The following example demonstrates how to disable the "employees" group we created above:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");
  employees.setEnabled(false);
  identityManager.update(employees);]]></programlisting>
        
        <para>
          To remove an existing group, we can use the <code>remove()</code> method:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");
  identityManager.remove(employees);]]></programlisting>

      </section>
    </section>
    
    <section>
      <title>Managing Relationships</title>
      
      <para>
        Relationships are used to model <emphasis>typed associations</emphasis> between two or more identities.  All 
        concrete relationship types must implement the marker interface <code>org.picketlink.idm.model.Relationship</code>:
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/relationshipclassdiagram.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/relationshipclassdiagram.png" align="center"/>
        </imageobject>
      </mediaobject> 
                    
      <para>
        The <code>IdentityManager</code> interface provides three standard methods for managing relationships:
      </para>
      
      <programlisting language="JAVA"><![CDATA[  void add(Relationship relationship);
  void update(Relationship relationship);
  void remove(Relationship relationship);]]></programlisting>
      
      <itemizedlist>
        <listitem>
          <para>
            The <code>add()</code> method is used to create a new relationship.
          </para>
        </listitem>
        
        <listitem>
          <para>
            The <code>update()</code> method is used to update an existing relationship.
          </para>
          
          <note>
            <para>
              Please note that the identities that participate in a relationship cannot be updated themselves, 
              however the attribute values of the relationship can be updated.  If you absolutely need to modify
              the identities of a relationship, then delete the relationship and create it again.
            </para>
          </note>
        </listitem>
        
        <listitem>
          <para>
            The <code>remove()</code> method is used to remove an existing relationship.
          </para>
        </listitem>
      </itemizedlist>
      
      <note>
        <para>
          To search for existing relationships between identity objects, use the Relationship Query API described later
          in this chapter.
        </para>
      </note>
      
      <para>
        Besides the above methods, <code>IdentityManager</code> also provides a number of convenience methods for
        managing many of the built-in relationship types.  See the next section for more details.
      </para>
            
      <section>
        <title>Built In Relationship Types</title>
        
        <para>
          PicketLink provides a number of built-in relationship types, designed to address the most common requirements
          of a typical application.  The following sections describe the built-in relationships and how they are intended
          to be used.  Every built-in relationship type extends the <code>AbstractAttributedType</code> abstract class,
          which provides the basic methods for setting a unique identifier value and managing a set of attribute values:
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/abstractattributedtype.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/abstractattributedtype.png" align="center"/>
          </imageobject>
        </mediaobject> 
        
        <para>
          What this means in practical terms, is that every single relationship is assigned and can be identified by, a unique 
          identifier value.  Also, arbitrary attribute values may be set for all relationship types, which is useful if you 
          require additional metadata or any other type of information to be stored with a relationship.
        </para>
        
        <section>
          <title>Grant</title>
          
          <para>
            A <code>Grant</code> relationship is used to assign a <code>Role</code> to an identity type such as a <code>User</code>
            or <code>Agent</code>.  It is typically used to represent an <emphasis>application role</emphasis>, in which an entity
            is granted the privilege to perform certain restricted operations within the scope of an application or service.
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/grant.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/grant.png" align="center"/>
            </imageobject>
          </mediaobject> 
          
          <para>
            The <code>IdentityManager</code> interface provides methods for directly granting a role.  Here's a simple example:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  identityManager.grantRole(bob, superuser);]]></programlisting>
          
          <para>
            The above code is equivalent to the following:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  Grant grant = new Grant(bob, superuser);
  identityManager.add(grant);]]></programlisting>
  
          <para>
            A granted role can also be revoked using the <code>revokeRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  identityManager.revokeRole(bob, superuser);]]></programlisting>
  
          <para>
            To check whether an identity has a specific role granted to them, we can use the <code>hasRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  boolean isBobASuperUser = identityManager.hasRole(bob, superuser);]]></programlisting>
        </section>
        
        <section>
          <title>Group Membership</title>
          
          <para>
            The <code>GroupMembership</code> relationship is used to represent an identity's membership of a <code>Group</code>.
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/groupmembership.png" align="center" scalefit="0"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/groupmembership.png" align="center"/>
            </imageobject>
          </mediaobject>           
          
          <para>
            A <code>Group</code> is typically used to form logical collections of users.  Within an organisation, groups are 
            often used to mirror the organisation's structure.  For example, a corporate structure might consist of a sales
            department, administration, management, etc.  This structure can be modelled in PicketLink by creating corresponding
            groups such as <emphasis>sales</emphasis>, <emphasis>administration</emphasis>, and so forth.  Users (who would represent 
            the employees in a corporate structure) may then be assigned group memberships corresponding to their place within 
            the company's organisational structure.  For example, an employee who works in the sales department 
            may be assigned to the <emphasis>sales</emphasis> group.
            Specific application privileges can then be blanket assigned to the <emphasis>sales</emphasis> group, and anyone who 
            is a member of the group is free to access the application's features that require those privileges.
          </para>
          
          <para>
            Let's start by looking at a simple example.  The following code demonstrates how we would create the hypothetical 
            <emphasis>sales</emphasis> group described above, and assign group membership to user "janet":
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group sales = new SimpleGroup("sales");
  identityManager.add(sales);
  User janet = identityManager.getUser("janet");
  identityManager.addToGroup(janet, sales);]]></programlisting>
          
          <para>
            A <code>User</code> may also be a member of more than one <code>Group</code>; there are no built-in limitations on 
            the number of groups that a <code>User</code> may be a member of.  
          </para>
          
          <para>
            We can use the <code>removeFromGroup()</code> method to remove the user from the group:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group sales = identityManager.getGroup("sales");
  User janet = identityManager.getUser("janet");
  identityManager.removeFromGroup(janet, sales);]]></programlisting>
  
          <para>
            To check whether an identity is the member of a group we can use the <code>isMember()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group sales = identityManager.getGroup("sales");
  User janet = identityManager.getUser("janet");
  boolean isJanetInSales = identityManager.isMember(janet, sales);]]></programlisting>
        </section>
        
        <section>
          <title>Group Role</title>
          
          <para>
            The <code>GroupRole</code> relationship type extends <code>GroupMembership</code> by adding a role property, and is
            used to represent identities that have a specific role within the context of a group. 
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/grouprole.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/grouprole.png" align="center"/>
            </imageobject>
          </mediaobject>   
          
          <note>
            <para>
              While the <code>GroupRole</code> relationship type extends <code>GroupMembership</code>, it does <emphasis>not</emphasis> 
              mean that a member of a <code>GroupRole</code> automatically receives <code>GroupMembership</code> membership also.
            </para>
          </note>
          
          <para>
            The <code>GroupRole</code> relationship type should be used when it is intended for an identity to perform a specific
            role for a group, but not be an actual member of the group itself.  For example, an administrator of a group of doctors
            may not be a doctor themselves, but have an administrative role to perform for them.  If the intent is for an individual
            identity to both be a member of a group <emphasis>and</emphasis> have an assigned role in that group also, then the identity
            should have both <code>GroupRole</code> and <code>GroupMembership</code> relationships for that group.
          </para>
          
          <para>
            The <code>IdentityManager</code> interface provides some convenience methods for managing group roles.  The following example
            demonstrates how to assign a group role to a user:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group doctors = new SimpleGroup("doctors");
  identityManager.add(doctors);
  User sally = identityManager.getUser("sally");
  Role admin = identityManager.getRole("administrator");
  identityManager.grantGroupRole(sally, doctors, admin);]]></programlisting>
  
          <para>
            The above code is equivalent to creating a <code>GroupRole</code> relationship manually, and adding it via the 
            <code>add()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group doctors = new SimpleGroup("doctors");
  identityManager.add(doctors);
  User sally = identityManager.getUser("sally");
  Role admin = identityManager.getRole("administrator");
  GroupRole groupRole = new GroupRole(sally, doctors, admin);
  identityManager.add(groupRole);]]></programlisting>
  
          <para>
            A group role can be revoked using the <code>revokeGroupRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User sally = identityManager.getUser("sally");
  Role admin = identityManager.getRole("administrator");
  Group doctors = identityManager.getGroup("doctors");
  identityManager.revokeGroupRole(sally, admin, doctors);]]></programlisting>
  
          <para>
            To test whether an identity has a particular group role, you can use the <code>hasGroupRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User sally = identityManager.getUser("sally");
  Role admin = identityManager.getRole("administrator");
  Group doctors = identityManager.getGroup("doctors");
  boolean isSallyDoctorsAdmin = identityManager.hasGroupRole(sally, admin, doctors);]]></programlisting>
  
        </section>

      </section>
      
      <section>
        <title>Creating Custom Relationships</title>
        
        <para>
          One of the strengths of PicketLink is its ability to support custom relationship types.  This extensibility allows you, the
          developer to create specific relationship types between two or more identities to address the domain-specific requirements
          of your own application.  
        </para>
        
        <note>
          <para>
            Please note that custom relationship types are not supported by all <code>IdentityStore</code> implementations - 
            see the Identity Store section above for more information.
          </para>
        </note>
        
        <para>
          To create a custom relationship type, we start by creating a new class that implements the <code>Relationship</code> interface.
          To save time, we also extend the <code>AbstractAttributedType</code> abstract class which takes care of the identifier and
          attribute management methods for us:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  public class Authorization extends AbstractAttributedType implements Relationship {
        
  }]]></programlisting>
        
        <para>
          The next step is to define which identities participate in the relationship.  Once we create our identity property methods,
          we also need to annotate them with the <code>org.picketlink.idm.model.annotation.RelationshipIdentity</code> annotation.  
          This is done by creating a property for each identity type.
        </para>
        
        <programlisting language="JAVA"><![CDATA[  private User user;
  private Agent application;
  
  @RelationshipIdentity
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  @RelationshipIdentity
  public Agent getApplication() {
    return application;
  }
  
  public void setApplication(Agent application) {
    this.application = application;
  }]]></programlisting>
          
          <code>
            We can also define some attribute properties, using the <code>@RelationshipAttribute</code> annotation:
          </code>
          
          <programlisting language="JAVA"><![CDATA[  private String accessToken;
  
  @RelationshipAttribute
  public String getAccessToken() {
    return accessToken;
  }
  
  public void setAccessToken(String accessToken) {
    this.accessToken = accessToken;
  }]]></programlisting>
      </section>
      
    </section>
    
    <section>
      <title>Authentication</title>
      
      <note>
        <para>
          While the IDM module of PicketLink provides authentication features, for common use cases involving standard username and
          password based authentication in a Java EE environment, the PicketLink core module provides a more streamlined method
          of authentication.  Please refer to the authentication chapter of this documentation for more information.
        </para>
      </note>
      
      <para>
        PicketLink IDM provides an authentication subsystem that allows user credentials to be validated thereby confirming
        that an authenticating user is who they claim to be.  The <code>IdentityManager</code> interface provides a single
        method for performing credential validation, as follows:
      </para>
      
      <programlisting language="JAVA"><![CDATA[void validateCredentials(Credentials credentials);]]></programlisting>
      
      <para>
        The <code>validateCredentials()</code> method accepts a single <code>Credentials</code> parameter, which should
        contain all of the state required to determine who is attempting to authenticate, and the credential (such as a
        password, certificate, etc) that they are authenticating with.  Let's take a look at the <code>Credentials</code>
        interface:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface Credentials {
    public enum Status {
        UNVALIDATED, IN_PROGRESS, INVALID, VALID, EXPIRED
    };

   Agent getValidatedAgent();
   
   Status getStatus();
   
   void invalidate();
}]]></programlisting>

      <itemizedlist>
        <listitem>
          <para>
            The <code>Status</code> enum defines the following values, which reflect the various credential states:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <code>UNVALIDATED</code> - The credential is yet to be validated.
              </para>
            </listitem>
            <listitem>
              <para>
                <code>IN_PROGRESS</code> - The credential is in the process of being validated.
              </para>
            </listitem>
            <listitem>
              <para>
                <code>INVALID</code> - The credential has been validated unsuccessfully
              </para>
            </listitem>
            <listitem>
              <para>
                <code>VALID</code> - The credential has been validated successfully
              </para>
            </listitem>
            <listitem>
              <para>
                <code>EXPIRED</code> - The credential has expired
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <code>getValidatedAgent()</code> - If the credential was successfully validated, this method returns the
            <code>Agent</code> object representing the validated user.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>getStatus()</code> - Returns the current status of the credential, i.e. one of the above enum values.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>invalidate()</code> - Invalidate the credential.  Implementations of <code>Credential</code> should use
            this method to clean up internal credential state.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Let's take a look at a concrete example - <code>UsernamePasswordCredentials</code> is a <code>Credentials</code>
        implementation that supports traditional username/password-based authentication:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public class UsernamePasswordCredentials extends AbstractBaseCredentials {

    private String username;

    private Password password;

    public UsernamePasswordCredentials() { }

    public UsernamePasswordCredentials(String userName, Password password) {
        this.username = userName;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public UsernamePasswordCredentials setUsername(String username) {
        this.username = username;
        return this;
    }

    public Password getPassword() {
        return password;
    }

    public UsernamePasswordCredentials setPassword(Password password) {
        this.password = password;
        return this;
    }

    @Override
    public void invalidate() {
        setStatus(Status.INVALID);
        password.clear();
    }
}]]></programlisting>

      <para>
        The first thing we may notice about the above code is that the <code>UsernamePasswordCredentials</code> class extends
        <code>AbstractBaseCredentials</code>.  This abstract base class implements the basic functionality required by the 
        <code>Credentials</code> interface.  Next, we can see that two fields are defined; <code>username</code> and <code>password</code>.
        These fields are used to hold the username and password state, and can be set either via the constructor,
        or by their associated setter methods.  Finally, we can also see that the <code>invalidate()</code> method sets the status to
        <code>INVALID</code>, and also clears the password value.
      </para>
      
      <para>
        Let's take a look at an example of the above classes in action.  The following code demonstrates how we would authenticate
        a user with a username of "john" and a password of "abcde":
      </para>
      
      <programlisting language="JAVA"><![CDATA[Credentials creds = new UsernamePasswordCredentials("john",
    new Password("abcde"));
identityManager.validate(creds);
if (Status.VALID.equals(creds.getStatus())) {
  // authentication was successful
}]]></programlisting>
    
      <para>
        We can also test if the credentials that were provided have expired (if an expiry date was set).  In this case we might
        redirect the user to a form where they can enter a new password.
      </para>
      
      <programlisting language="JAVA"><![CDATA[Credentials creds = new UsernamePasswordCredentials("john",
    new Password("abcde"));
identityManager.validate(creds);
if (Status.EXPIRED.equals(creds.getStatus())) {
  // password has expired, redirect the user to a password change screen
}]]></programlisting>
      
    </section>

    <section>
      <title>Managing Credentials</title>
      
      <para>
        Updating user credentials is even easier than validating them.  The <code>IdentityManager</code> interface provides the following
        two methods for updating credentials:
      </para>
      
      <programlisting language="JAVA"><![CDATA[void updateCredential(Agent agent, Object credential);
void updateCredential(Agent agent, Object credential, Date effectiveDate, Date expiryDate);]]></programlisting>

      <para>
        Both of these methods essentially do the same thing; they update a credential value for a specified <code>Agent</code>
        (or <code>User</code>).  The second overloaded method however also accepts <code>effectiveDate</code> and <code>expiryDate</code> 
        parameters, which allow some temporal control over when the credential will be valid.  Use cases for this feature 
        include implementing a strict password expiry policy (by providing an expiry date), or creating a new account that might not 
        become active until a date in the future (by providing an effective date).  Invoking the first overloaded method will
        store the credential with an effective date of the current date and time, and no expiry date.
      </para>

      <note>      
        <para>
          One important point to note is that the <code>credential</code> parameter is of type <code>java.lang.Object</code>.  Since
          credentials can come in all shapes and sizes (and may even be defined by third party libraries), there is no common base 
          interface for credential implementations to extend.  To support this type of flexibility in an extensible way, PicketLink 
          provides an SPI that allows custom credential handlers to be configured that override or extend the default credential 
          handling logic.  Please see the next section for more information on how this SPI may be used.
        </para>
      </note>
      
      <para>
        PicketLink provides built-in support for the following credential types:
      </para>
      
      <warning>
        <para>
          Not all built-in <code>IdentityStore</code> implementations support all credential types.  For example, since the
          <code>LDAPIdentityStore</code> is backed by an LDAP directory server, only password credentials are supported.  The
          following table lists the built-in <code>IdentityStore</code> implementations that support each credential type.
        </para>
      </warning>
      
      <table>
        <title>Built-in credential types</title>
        
        <tgroup cols="3" align="left">
          <thead>
            <row>
              <entry>Credential type</entry>
              <entry>Description</entry>
              <entry>Supported by</entry>
            </row>
          </thead>
          <tbody valign="top">
            <row>
              <entry><code>org.picketlink.idm.credential.Digest</code></entry>
              <entry>Used for digest-based authentication</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>
              </entry>
            </row>
            <row>
              <entry><code>org.picketlink.idm.credential.Password</code></entry>
              <entry>A standard text-based password</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>
                <code>LDAPIdentityStore</code>
              </entry>
            </row>
            <row>
              <entry><code>java.security.cert.X509Certificate</code></entry>
              <entry>Used for X509 certificate based authentication</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>             
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
           
      <para>
        Let's take a look at a couple of examples.  Here's some code demonstrating how a password can be assigned
        to user "jsmith":
      </para>
      
      <programlisting language="JAVA"><![CDATA[User user = identityManager.getUser("jsmith");
identityManager.updateCredential(user, new Password("abcd1234"));]]></programlisting>

      <para>
        This example creates a digest and assigns it to user "jdoe":
      </para>
      
      <programlisting language="JAVA"><![CDATA[User user = identityManager.getUser("jdoe");
Digest digest = new Digest();
digest.setRealm("default");
digest.setUsername(user.getLoginName());
digest.setPassword("abcd1234");        
identityManager.updateCredential(user, digest);]]></programlisting>
      
    </section>
    
    <section>
      <title>Credential Handlers</title>
      
      <para>
        For <code>IdentityStore</code> implementations that support multiple credential types, PicketLink provides
        an optional SPI to allow the default credential handling logic to be easily customized and extended. To get
        a better picture of the overall workings of the Credential Handler SPI, let's take a look at the sequence
        of events during the credential validation process when validating a username and password against
        <code>JPAIdentityStore</code>:
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/username_password_validation.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/username_password_validation.png" align="center"/>
        </imageobject>
      </mediaobject>       
      
     <itemizedlist>
        <listitem>
          <para>
            <emphasis>1</emphasis> -
            The user (or some other code) first invokes the <code>validateCredentials()</code> method on <code>IdentityManager</code>,
            passing in the <code>Credentials</code> instance to validate.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>1.1</emphasis> -
            After looking up the correct <code>IdentityStore</code> (i.e. the one that has been configured to validate credentials)
            the <code>IdentityManager</code> invokes the store's <code>validateCredentials()</code> method, passing in the
            <code>SecurityContext</code> and the credentials to validate.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>1.1.1</emphasis> - 
            In <code>JPAIdentityStore</code>'s implementation of the <code>validateCredentials()</code> method, the 
            <code>SecurityContext</code> is used to look up the <code>CredentialHandler</code> implementation that has been 
            configured to process validation requests for usernames and passwords, which is then stored in a local variable
            called <code>handler</code>.
          </para>
        </listitem>
        <listitem>                
          <para>
            <emphasis>1.1.2</emphasis> -
            The <code>validate()</code> method is invoked on the <code>CredentialHandler</code>, passing in the security context,
            the credentials value and a reference back to the identity store.  The reference to the identity store is important
            as the credential handler may require it to invoke certain methods upon the store to validate the credentials.
          </para>
        </listitem>
      </itemizedlist>           
      
      <para>
        The <code>CredentialHandler</code> interface declares three methods, as follows:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface CredentialHandler {
    void setup(IdentityStore<?> identityStore);

    void validate(SecurityContext context, Credentials credentials, 
                  IdentityStore<?> identityStore);

    void update(SecurityContext context, Agent agent, Object credential, 
                IdentityStore<?> identityStore, Date effectiveDate, Date expiryDate);

}]]></programlisting>

      <para>
        The <code>setup()</code> method is called once, when the <code>CredentialHandler</code> instance is first created. 
        Credential handler instantiation is controlled by the <code>CredentialHandlerFactory</code>, which creates a single
        instance of each <code>CredentialHandler</code> implementation to service all credential requests for that handler.
        Each <code>CredentialHandler</code> implementation must declare the types of credentials that it is capable of supporting,
        which is done by annotating the implementation class with the <code>@SupportsCredentials</code> annotation like so:
      </para>
    
      <programlisting language="JAVA"><![CDATA[@SupportsCredentials({ UsernamePasswordCredentials.class, Password.class })
public class PasswordCredentialHandler implements CredentialHandler {]]></programlisting>
  
      <para>
        Since the <code>validate()</code> and <code>update()</code> methods receive different parameter types (<code>validate()</code>
        takes a <code>Credentials</code> parameter value while <code>update()</code> takes an <code>Object</code> that represents
        a single credential value), the <code>@SupportsCredentials</code> annotation must contain a complete list of all types supported
        by that handler.
      </para>
      
      <para>
        Similarly, if the <code>IdentityStore</code> implementation makes use of the credential handler SPI then it also must declare
        which credential handlers support that identity store.  This is done using the <code>@CredentialHandlers</code> annotation; 
        for example, the following code shows how <code>JPAIdentityStore</code> is configured to be capable of handling credential
        requests for usernames and passwords, X509 certificates and digest-based authentication:
      </para>
      
      <programlisting language="JAVA"><![CDATA[@CredentialHandlers({ PasswordCredentialHandler.class,
          X509CertificateCredentialHandler.class, DigestCredentialHandler.class })
public class JPAIdentityStore implements IdentityStore<JPAIdentityStoreConfiguration>, 
                                         CredentialStore {]]></programlisting>
                                         
      <section>
        <title>The CredentialStore interface</title>
        
        <para>
          For <code>IdentityStore</code> implementations that support multiple credential types (such as <code>JPAIdentityStore</code>
          and <code>FileBasedIdentityStore</code>), the implementation may choose to also implement the <code>CredentialStore</code>
          interface to simplify the interaction between the <code>CredentialHandler</code> and the <code>IdentityStore</code>.  The
          <code>CredentialStore</code> interface declares methods for storing and retrieving credential values within an identity
          store, as follows:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public interface CredentialStore {
   void storeCredential(SecurityContext context, Agent agent, 
                        CredentialStorage storage);
   <T extends CredentialStorage> T retrieveCurrentCredential(SecurityContext context, 
                                                 Agent agent, Class<T> storageClass);
   <T extends CredentialStorage> List<T> retrieveCredentials(SecurityContext context, 
                                                 Agent agent, Class<T> storageClass);
}]]></programlisting>

        <para>
          The <code>CredentialStorage</code> interface is quite simple and only declares two methods, <code>getEffectiveDate()</code>
          and <code>getExpiryDate()</code>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public interface CredentialStorage {
   @Stored Date getEffectiveDate();
   @Stored Date getExpiryDate();
}]]></programlisting>

        <para>
          The most important thing to note above is the usage of the <code>@Stored</code> annotation.  This annotation is used to
          mark the properties of the <code>CredentialStorage</code> implementation that should be persisted.  The only requirement
          for any property values that are marked as <code>@Stored</code> is that they are serializable (i.e. they implement the
          <code>java.io.Serializable</code> interface).  The <code>@Stored</code> annotation may be placed on either the getter 
          method or the field variable itself.  Here's an example of one of a <code>CredentialStorage</code> implementation that
          is built into PicketLink - <code>EncodedPasswordStorage</code> is used to store a password hash and salt value:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public class EncodedPasswordStorage implements CredentialStorage {

    private Date effectiveDate;
    private Date expiryDate;
    private String encodedHash;
    private String salt;

    @Override @Stored
    public Date getEffectiveDate() {
        return effectiveDate;
    }

    public void setEffectiveDate(Date effectiveDate) {
        this.effectiveDate = effectiveDate;
    }

    @Override @Stored
    public Date getExpiryDate() {
        return expiryDate;
    }

    public void setExpiryDate(Date expiryDate) {
        this.expiryDate = expiryDate;
    }

    @Stored
    public String getEncodedHash() {
        return encodedHash;
    }

    public void setEncodedHash(String encodedHash) {
        this.encodedHash = encodedHash;
    }

    @Stored
    public String getSalt() {
        return this.salt;
    }

    public void setSalt(String salt) {
        this.salt = salt;
    }

}]]></programlisting>
      
      </section>

    </section>
    
    <section>
      <title>Built-in Credential Handlers</title>
     
      <para>
        This section describes each of the built-in credential handlers, and any configuration parameters that may be set for them.
        Specific credential handler options can be set when creating a new <code>IdentityConfiguration</code>.  Configured options 
        are always specific to a particular identity store configuration, allowing different options to be specified between two or
        more identity stores.  The <code>IdentityStoreConfiguration</code> interface provides a method called
        <code>getCredentialHandlersConfig()</code> that provides access to a <code>Map</code> which allows configuration options
        to be set for the identity store's credential handlers:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface IdentityStoreConfiguration {
    Map<String, Object> getCredentialHandlerProperties();
}]]></programlisting>

      <para>
        To gain access to the <code>IdentityStoreConfiguration</code> object before PicketLink is initialized, there are a couple of
        options.  The first option is to provide an <code>IdentityConfiguration</code> object itself via a producer method.
      </para>
      
      <programlisting language="JAVA"><![CDATA[
      
      ]]></programlisting>

      <section>
        <title></title>
        
        <para>
        
        </para>
      </section>

    </section>
    
    <section>
      <title>Advanced Topics</title>
      
      <section>
        <title>Multi Realm Support</title>
        
        <para>
          PicketLink has been designed from the ground up to support a system of <emphasis>partitioning</emphasis>, allowing the
          users, groups and roles of an application to be divided into <emphasis>Realms</emphasis> and <emphasis>Tiers</emphasis>.
        </para>
             
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/realm_tier.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/realm_tier.png" align="center"/>
          </imageobject>
        </mediaobject>   
        
        <para>
          A <emphasis>Realm</emphasis> is used to define a discrete set of users, groups and roles.  A typical use case for realms
          is the segregation of corporate user accounts within a multi-tenant application, although it is not limited this use case only.
          As all identity management operations must be performed within the context of an <emphasis>active partition</emphasis>, 
          PicketLink defines the concept of a <emphasis>default realm</emphasis> which becomes the active partition if no other 
          partition has been specified.
        </para>
        
        <para>
          A <emphasis>Tier</emphasis> is a more restrictive type of partition than a realm, as it only allows groups and roles to be 
          defined (but not users).  A Tier may be used to define a set of application-specific groups and roles, which may then be 
          assigned to groups within the same Tier, or to users and groups within a separate Realm.
        </para>
        
        <para>
          In terms of API, both the <code>Realm</code> and <code>Tier</code> classes implement the <code>Partition</code> interface,
          as shown in the following class diagram:
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/partition.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/partition.png" align="center"/>
          </imageobject>
        </mediaobject> 
        
        <para>
          Selecting the specific partition that the identity management operations are performed in is controlled by specifying 
          the partition when creating the <code>IdentityManager</code> via the <code>IdentityManagerFactory</code>'s overloaded 
          <code>createIdentityManager()</code> methods:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  IdentityManager createIdentityManager();
    IdentityManager createIdentityManager(Partition partition);]]></programlisting>
    
        <para>
          The first method (without parameters) will create an <code>IdentityManager</code> instance for the default realm.  The
          second parameter allows a <code>Partition</code> object to be specified.  Once the <code>IdentityManager</code> has been
          created, any identity management methods invoked on it will be performed within the selected partition.  To look up the 
          partition object, the <code>IdentityManagerFactory</code> provides two additional methods:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Realm getRealm(String id);
    Tier getTier(String id);]]></programlisting>
    
        <para>
          Here's an example demonstrating how a new user called "bob" is created in a realm called <emphasis>acme</emphasis>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Realm acme = identityManagerFactory.getRealm("acme");
    IdentityManager im = identityManagerFactory.createIdentityManager(acme);
    im.add(new SimpleUser("bob"));]]></programlisting>
        
      </section>      
      
    </section>

</chapter>
