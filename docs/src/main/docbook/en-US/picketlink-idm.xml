<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Identity Management</title>
  
    <section>
      <title>Overview</title>
      
      <para>
        PicketLink's Identity Management (IDM) features provide a rich and extensible API for managing the users, groups and roles of
        your applications and services. The <code>org.picketlink.idm.IdentityManager</code> interface declares all the methods required to
        create, update and delete Identity objects and create relationships between them such as group and role memberships.
      </para>
      
      <para>
        Interaction with the backend store that provides the persistent identity state is performed by configuring one or more
        <code>IdentityStore</code>s.  PicketLink provides a few built-in <code>IdentityStore</code> implementations for storing
        identity state in a database, file system or LDAP directory server, and it is possible to provide your own custom
        implementation to support storing your application's identity data in other backends, or extend the built-in implementations
        to override their default behaviour.
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/identity_manager_stores.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/identity_manager_stores.png" align="center"/>
        </imageobject>
      </mediaobject> 
      
      <para>
        Before PicketLink IDM can be used, it must first be configured.  See the configuration section below for details on
        how to configure IDM for both Java EE and Java SE environments.
      </para>
    </section>
    
    <section>
      <title>Identity Model</title>
      
      <para>
        PicketLink's identity model consists of a number of core interfaces that define the fundamental identity types
        upon which much of the Identity Management API is based.  The following class diagram shows the classes and interfaces
        in the <code>org.picketlink.idm.model</code> package that form the base identity model.
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/identitymodel.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/identitymodel.png" align="center"/>
        </imageobject>
      </mediaobject>      
      
      <itemizedlist>
        <listitem>
          <para>
            <code>AttributedType</code> is the base interface for the identity model.  It declares a number of methods for
            managing a set of attribute values, plus <code>getId()</code> and <code>setId()</code> methods for setting a 
            unique UUID value.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Attribute</code> is used to represent an attribute value.  An attribute has a name and a (generically typed) value,
            and may be marked as read-only.  Attribute values that are expensive to load (such as large binary data) may be lazy-loaded; 
            the <code>isLoaded()</code> method may be used to determine whether the Attribute has been loaded or not.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>IdentityType</code> is the base interface for Identity objects.  It declares properties that indicate whether the
            identity object is enabled or not, optional created and expiry dates, plus methods to read and set the owning 
            <code>Partition</code>.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Agent</code> represents a unique entity that may access the services secured by PicketLink.  In contrast to a user
            which represents a human, <code>Agent</code> is intended to represent a third party non-human (i.e. machine to machine) 
            process that may authenticate and interact with your application or services.  It declares methods for reading and setting
            the <code>Agent</code>'s login name.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>User</code> represents a human user that accesses your application and services.  In addition to the login name
            property defined by its parent interface <code>Agent</code>, the <code>User</code> interface declares a number of other
            methods for managing the user's first name, last name and e-mail address.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Group</code> is used to manage collections of identity types.  Each <code>Group</code> has a name and an optional
            parent group.
          </para>
        </listitem>
        
        <listitem>
          <para>
            <code>Role</code> is used in various relationship types to designate authority to another identity type to perform
            various operations within an application.  For example, a forum application may define a role called 
            <emphasis>moderator</emphasis> which may be assigned to one or more <code>User</code>s or <code>Group</code>s to indicate 
            that they are authorized to perform moderator functions.
          </para>
        </listitem>
      
      </itemizedlist>
      <section>
          <title>Architectural Overview</title>
          <para>The following diagram shows the main components that realize PicketLink Identity Management:</para>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/idm_architecture_overview.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/idm_architecture_overview.png" align="center"/>
            </imageobject>
          </mediaobject>
          <para>
          	<itemizedlist>
        		<listitem>
          			<para>
            			<code>IdentityConfiguration</code> is the the class responsible for holding all PicketLink configuration options. 
            			This class is usually built using the Configuration Builder API, which we'll cover in the next sections. 
            			Once created and populated with the configuration options, an instance is used to create a <code>IdentityManagerFactory</code>.
          			</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>IdentityManagerFactory</code> is the class from which <code>IdentityManager</code> instances are created for a specific <emphasis>realm</emphasis>, 
            			considering all configurations provided by a <code>IdentityConfiguration</code> instance. 
          			</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>SecurityContextFactory</code> is an interface that provides methods for creating <code>SecurityContext</code> instances. This component knows how to properly create and prepare 
            			the context that will be propagated during identity management operations.   
          			</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>SecurityContext</code> is the class that holds context data that will be used during the execution of identity management operations. 
            			Once created, the context is used to create <code>IdentityStore</code> instances and to invoke their methods.
            		</para>
            		<para>This component allows to share data between the <code>IdentityManager</code> and <code>IdentityStore</code> instances. 
            		And also provides direct access for some IDM subsystems such as: event handling, caching and so on.</para>
            		<para>Beyond that, this component is critical when access to external resources are required, such as the current <code>EntityManager</code> when using a JPA-based store.</para>
            		<para> 
            			<emphasis>Each <code>IdentityManager</code> instance is associated with a single <code>SecurityContext</code>.</emphasis>     
          			</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>StoreFactory</code> is an interface that provides methods for creating <code>IdentityStore</code> instances. 
            			Instances are created considering the <emphasis>Feature Set</emphasis> supported by each identity store and also the current <code>SecurityContext</code> instance.
            		</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>IdentityStore</code> is an interface that provides a contract for implementations that store data using a specific repository such as: LDAP, databases, file system, etc.
            		</para>
            		<para>It is a critical component as it provides all the necessary logic about how to store data.</para>
       	 		</listitem>
        		<listitem>
          			<para>
            			<code>IdentityManager</code> is an interface that provides a simple access for all identity management operations using one or more of the configured identity stores.
            		</para>
            		<para>All functionality provided by PicketLink is available from this interface, from where applications will interact most of the time.</para>
       	 		</listitem>
       	 	</itemizedlist>
          </para>
          <para>For most use cases, users will only work with the <code>IdentityManagerFactory</code> and <code>IdentityManager</code> classes. 
          Only advanced use cases may require a deep knowledge about other components in order to customize the default behaviour/implementation to suit a specific requirement.</para>
          <para>The diagram bellow shows a overview about how a specific identity management operation is realized:</para>
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/idm_operation_execution.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/idm_operation_execution.png" align="center"/>
            </imageobject>
          </mediaobject>
      </section>
    </section>
          
    <section>
      <title>Configuration</title>
    
        <section>
          <title>Architectural Overview</title>
          
          <para>
            Configuration in PicketLink is in essence quite simple; an <code>IdentityConfiguration</code> object must first 
            be created to hold the PicketLink configuration options.  Once all configuration options have been set, you just create a 
            <code>IdentityManagerFactory</code> instance passing the previously created configuration.            
            The <code>IdentityManagerFactory</code> can then be used to create <code>IdentityManager</code> instances 
            via the <code>createIdentityManager()</code> method.  
          </para>          
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/architecture.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/architecture.png" align="center"/>
            </imageobject>
          </mediaobject>

          <para>
            The <code>IdentityConfiguration</code> is usually created using a Configuration Builder API, which provides a rich and fluent API for every single aspect of PicketLink configuration.
		  </para>

          <note>
            <para>
              For now, all configuration is set programmatically using the Configuration Builder API only. Later versions will also support a declarative configuration in a form of XML documents.   
            </para>
          </note>
			          
          <para>
            Each <code>IdentityManager</code> instance has its own <emphasis>security context</emphasis>, represented by
            the <code>SecurityContext</code> class.  The security context contains temporary state which is maintained 
            for one or more identity management operations within the scope of a single realm or tier.  The 
            <code>IdentityManager</code> (and its associated <code>SecurityContext</code>) is typically modelled as a
            request-scoped object (for environments which support such a paradigm, such as a servlet container), or alternatively
            as an actor within the scope of a transaction.  In the latter case, the underlying resources being 
            utilised by the configured identity stores (such as a JPA <code>EntityManager</code>) would participate in 
            the active transaction, and changes made as a result of any identity management operations would either be 
            committed or rolled back as appropriate for the logic of the encapsulating business method.
          </para>
            
          <para>
            The following sections describe various ways that configuration may be performed in different environments.
          </para>
          
        </section>
      
      <section>
        <title>Programmatic Configuration</title>
      
        <para>
          Configuration for Identity Management can be defined programmatically using the Configuration Builder API. The aim of this API is to make it easier to chaing coding
          of configuration options in order to speed up the coding itself and make the configuration more <emphasis>readable</emphasis>.
        </para>
        <para>        
          Let's assume that you want to quick start with PicketLink Identity Management features using a file-based Identity Store. 
          First, a fresh instance of <code>IdentityConfiguration</code> is created using the <code>IdentityConfigurationBuilder</code> helper object, 
          where we choose which identity store we want to use (in this case a file-based store) and any other configuration option, if necessary. 
          Finally, we use the configuration to create a <code>IdentityManagerFactory</code> from where we can create <code>IdentityManager</code> instances and start to perform Identity Management operations: 
        </para>
        
        <programlisting><![CDATA[IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();
        
builder
    .stores()
        .file()
            .supportAllFeatures();

IdentityConfiguration configuration = builder.build();

IdentityManagerFactory identityManagerFactory = new IdentityManagerFactory(configuration);

IdentityManager identityManager = identityManagerFactory.createIdentityManager();

User user = new SimpleUser("john");

identityManager.add(user);]]></programlisting>

	  <section>
	  	<title>IdentityConfigurationBuilder for Programmatic Configuration</title>
	  	
	  	<para>The <code>IdentityConfigurationBuilder</code> is the entry point for PicketLink configuration. 
	  	It is a very simple class with some meanniful methods for all supported configuration options.</para>
		<programlisting><![CDATA[IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();

builder
	.stores() // supported identity stores configuration	
		.file() 
			// file-based identity store configuration
		.jpa()
			// JPA-based identity store configuration
		.ldap()
			// LDAP-based identity store configuration			
	.contextFactory(...); // for custom SecurityContextFactory implementations]]></programlisting>	
		<para>In the next sections we'll cover each supported Identity Store and their specific configuration.</para>			  	
	  </section>
        
      </section>
      
      <section>
        <title>Security Context Configuration</title>
      
        <para>
          TODO
        </para>
      </section>
            
      <section>
        <title>Identity Store Configurations</title>
      
        <para>
          For each of the built-in <code>IdentityStore</code> implementations there is a corresponding
          <code>IdentityStoreConfiguration</code> implementation - the following sections describe each of these in more detail.
        </para>

        <section>
	      <title>Feature Set</title>
	      
	      <para>
	         TODO
	      </para>
	    </section>
        
	      <section>
	        <title>JPAIdentityStoreConfiguration</title>
	        
	        <para>
	          The JPA identity store uses a relational database to store identity state.  The configuration for this identity store
	          provides control over which entity beans are used to store identity data, and how their fields should be used to store
	          various identity-related state.  The entity beans that store the identity data must be configured using the 
	          annotations found in the <code>org.picketlink.jpa.annotations</code> package.  All identity configuration annotations
	          listed in the tables below are from this package.
	        </para>
	        
	        <section>
	          <title>Configuring an EntityManager</title>
	          
	          <para>
	            Before the JPA identity store can be used, it must be provided with an <code>EntityManager</code> so that it can
	            connect to a database.  In Java EE this can be done by providing a producer method within your application that 
	            specifies the <code>@org.picketlink.annotations.PicketLink</code> qualifier, for example like so:
	          </para>
	          
	          <programlisting language="JAVA"><![CDATA[@Produces
	@PicketLink
	@PersistenceContext(unitName = "picketlink")
	private EntityManager picketLinkEntityManager;]]></programlisting>
	        </section>
	        
	        <section>
	          <title>Configuring the Identity class</title>
	          
	          <para>
	            The Identity class is the entity bean that is used to store the record for users, roles and groups. It should
	            be annotated with <code>@IdentityType</code> and declare the following field values:
	          </para>
	          
	          <table>
	            <title>Identity class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>ID</entry>
	                  <entry><code>@Identifier</code></entry>
	                  <entry>The unique identifier value for the identity (can also double as the primary key value)</entry>
	                </row>
	                <row>
	                  <entry>Discriminator</entry>
	                  <entry><code>@Discriminator</code></entry>
	                  <entry>Indicates the identity type (i.e. user, agent, group or role) of the identity.</entry>
	                </row>
	                <row>
	                  <entry>Partition</entry>
	                  <entry><code>@IdentityPartition</code></entry>
	                  <entry>The partition (realm or tier) that the identity belongs to</entry>
	                </row>
	                <row>
	                  <entry>Login name</entry>
	                  <entry><code>@LoginName</code></entry>
	                  <entry>The login name for agent and user identities (for other identity types this will be null)</entry>
	                </row>
	                <row>
	                  <entry>Name</entry>
	                  <entry><code>@IdentityName</code></entry>
	                  <entry>The name for group and role identities (for other identity types this will be null)</entry>
	                </row>
	                <row>
	                  <entry>First Name</entry>
	                  <entry><code>@FirstName</code></entry>
	                  <entry>The first name of a user identity</entry>
	                </row>
	                <row>
	                  <entry>Last Name</entry>
	                  <entry><code>@LastName</code></entry>
	                  <entry>The last name of a user identity</entry>
	                </row>
	                <row>
	                  <entry>E-mail</entry>
	                  <entry><code>@Email</code></entry>
	                  <entry>The primary e-mail address of a user identity</entry>
	                </row>
	                <row>
	                  <entry>Enabled</entry>
	                  <entry><code>@Enabled</code></entry>
	                  <entry>Indicates whether the identity is enabled</entry>
	                </row>
	                <row>
	                  <entry>Creation date</entry>
	                  <entry><code>@CreationDate</code></entry>
	                  <entry>The creation date of the identity</entry>
	                </row>
	                <row>
	                  <entry>Expiry date</entry>
	                  <entry><code>@ExpiryDate</code></entry>
	                  <entry>The expiry date of the identity</entry>
	                </row>
	                <row>
	                  <entry>Group parent</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent group (only used for Group identity types, for other types will be null)</entry>
	                </row>
	                <row>
	                  <entry>Group path</entry>
	                  <entry><code>@GroupPath</code></entry>
	                  <entry>Represents the full group path (for Group identity types only)</entry>
	                </row>
	              </tbody>
	            </tgroup>
	            
	          </table>
	          
	          <para>
	            The following code shows an example of an entity class configured to store Identity instances:
	          </para>
	          
	          <example>
	            <title>Example Identity class</title>
	            <programlisting language="JAVA"><![CDATA[@IdentityType
	@Entity
	public class IdentityObject implements Serializable {
	
	  @Discriminator
	  private String discriminator;
	
	  @ManyToOne
	  @IdentityPartition
	  private PartitionObject partition;
	
	  @Identifier
	  @Id
	  private String id;
	
	  @LoginName
	  private String loginName;
	
	  @IdentityName
	  private String name;
	
	  @FirstName
	  private String firstName;
	
	  @LastName
	  private String lastName;
	
	  @Email
	  private String email;
	
	  @Enabled
	  private boolean enabled;
	
	  @CreationDate
	  @Temporal(TemporalType.TIMESTAMP)
	  private Date creationDate;
	
	  @ExpiryDate
	  @Temporal(TemporalType.TIMESTAMP)
	  private Date expiryDate;
	
	  @ManyToOne
	  @Parent
	  private IdentityObject parent;
	
	  @GroupPath
	  private String groupPath;              
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	          
	        </section>
	        
	        <section>
	          <title>Configuring the Attribute class</title>
	          
	          <para>
	            The Attribute class is used to store Identity attributes, and should be annotated with
	            <code>@IdentityAttribute</code>
	          </para>
	          
	          <table>
	            <title>Attribute class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Identity</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent identity object to which the attribute value belongs</entry>
	                </row>
	                <row>
	                  <entry>Name</entry>
	                  <entry><code>@AttributeName</code></entry>
	                  <entry>The name of the attribute</entry>
	                </row>
	                <row>
	                  <entry>Value</entry>
	                  <entry><code>@AttributeValue</code></entry>
	                  <entry>The value of the attribute</entry>
	                </row>
	                <row>
	                  <entry>Type</entry>
	                  <entry><code>@AttributeType</code></entry>
	                  <entry>The fully qualified classname of the attribute value class</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>          
	          
	          <example>
	            <title>Example Attribute class</title>
	            <programlisting language="JAVA"><![CDATA[@Entity
	@IdentityAttribute
	public class IdentityAttribute implements Serializable {
	  @Id @GeneratedValue private Long id;
	
	  @ManyToOne @JoinColumn
	  @Parent
	  private IdentityObject identityObject;
	
	  @AttributeName
	  private String name;
	
	  @AttributeValue
	  private String value;
	
	  @AttributeType
	  private String type;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	          
	        </section>
	        
	        <section>
	          <title>Configuring the Credential class</title>
	          
	          <para>
	            The credential entity is used to store user credentials such as passwords and certificates, and should be annotated
	            with <code>@IdentityCredential</code>.
	          </para>
	          
	          <table>
	            <title>Credential class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Type</entry>
	                  <entry><code>@CredentialType</code></entry>
	                  <entry>The fully qualified classname of the credential type</entry>
	                </row>
	                <row>
	                  <entry>Value</entry>
	                  <entry><code>@CredentialValue</code></entry>
	                  <entry>The value of the credential</entry>
	                </row>
	                <row>
	                  <entry>Effective Date</entry>
	                  <entry><code>@EffectiveDate</code></entry>
	                  <entry>The effective date of the credential</entry>
	                </row>
	                <row>
	                  <entry>Expiry Date</entry>
	                  <entry><code>@ExpiryDate</code></entry>
	                  <entry>The expiry date of the credential</entry>
	                </row>
	                <row>
	                  <entry>Identity</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent identity to which the credential belongs</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Credential class</title>
	            <programlisting language="JAVA"><![CDATA[@Entity
	@IdentityCredential
	public class IdentityCredential implements Serializable {
	  @Id @GeneratedValue private Long id;
	
	  @CredentialType
	  private String type;
	
	  @CredentialValue
	  private String credential;
	
	  @EffectiveDate
	  @Temporal (TemporalType.TIMESTAMP)
	  private Date effectiveDate;
	
	  @ExpiryDate
	  @Temporal (TemporalType.TIMESTAMP)
	  private Date expiryDate;
	
	  @Parent
	  @ManyToOne
	  private IdentityObject identityType;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	            
	        </section>
	        
	        <section>
	          <title>Configuring the Credential Attribute class</title>
	          
	          <para>
	            The Credential Attribute class is used to store arbitrary attribute values relating to the credential.  It
	            should be annotated with <code>@CredentialAttribute</code>.
	          </para>
	          
	          <table>
	            <title>Credential Attribute class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Credential Object</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent credential to which this attribute belongs</entry>
	                </row>
	                <row>
	                  <entry>Attribute Name</entry>
	                  <entry><code>@AttributeName</code></entry>
	                  <entry>The name of the attribute</entry>
	                </row>
	                <row>
	                  <entry>Attribute Value</entry>
	                  <entry><code>@AttributeValue</code></entry>
	                  <entry>The value of the attribute</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Credential Attribute class</title>
	            <programlisting language="JAVA"><![CDATA[@Entity
	@CredentialAttribute
	public class IdentityCredentialAttribute implements Serializable {
	  @Id @GeneratedValue private Long id;
	
	  @ManyToOne @JoinColumn
	  @Parent
	  private IdentityCredential credential;
	
	  @AttributeName
	  private String name;
	
	  @AttributeValue
	  private String value;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	          
	        </section>
	        
	        <section>
	          <title>Configuring the Relationship class</title>
	          
	          <para>
	            Relationships are used to define typed associations between two or more identities.  The Relationship class should
	            be annotated with <code>@Relationship</code>.
	          </para>
	          
	          <table>
	            <title>Relationship class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Identifier</entry>
	                  <entry><code>@Identifier</code></entry>
	                  <entry>Unique identifier that represents the specific relationship (can also double as the primary key)</entry>
	                </row>
	                <row>
	                  <entry>Relationship Class</entry>
	                  <entry><code>@RelationshipClass</code></entry>
	                  <entry>The fully qualified class name of the relationship type</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Relationship class</title>
	            <programlisting language="JAVA"><![CDATA[@Relationship
	@Entity
	public class Relationship implements Serializable {
	  @Id 
	  @Identifier
	  private String id;
	
	  @RelationshipClass
	  private String type;
	
	  // getters and setters
	}]]></programlisting>
	          </example>
	        </section>
	        
	        <section>
	          <title>Configuring the Relationship Identity class</title>
	          
	          <para>
	            The Relationship Identity class is used to store the specific identities that participate in a relationship. It
	            should be annotated with <code>@RelationshipIdentity</code>.
	          </para>
	          
	          <table>
	            <title>Relationship Identity class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Relationship Descriptor</entry>
	                  <entry><code>@Discriminator</code></entry>
	                  <entry>Denotes the role of the identity in the relationship</entry>
	                </row>
	                <row>
	                  <entry>Relationship Identity</entry>
	                  <entry><code>@Identity</code></entry>
	                  <entry>The identity that is participating in the relationship</entry>
	                </row>
	                <row>
	                  <entry>Relationship</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent relationship object to which the relationship identity belongs</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Relationship Identity class</title>
	            <programlisting language="JAVA"><![CDATA[@RelationshipIdentity
	@Entity
	public class RelationshipIdentityObject implements Serializable {
	  @Id @GeneratedValue private Long id;
	
	  @Discriminator
	  private String descriptor;
	
	  @RelationshipIdentity
	  @ManyToOne
	  private IdentityObject identityObject;
	
	  @Parent
	  @ManyToOne
	  private RelationshipObject relationshipObject;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	        </section>
	        
	        <section>
	          <title>Configuring the Relationship Attribute class</title>
	          
	          <para>
	            The Relationship Attribute class is used to store arbitrary attribute values that relate to a specific relationship.
	            It should be annotated with <code>@RelationshipAttribute</code>.
	          </para>
	          
	          <table>
	            <title>Relationship Attribute class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>Relationship</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent relationship object to which the attribute belongs</entry>
	                </row>
	                <row>
	                  <entry>Attribute Name</entry>
	                  <entry><code>@AttributeName</code></entry>
	                  <entry>The name of the attribute</entry>
	                </row>
	                <row>
	                  <entry>Attribute value</entry>
	                  <entry><code>@AttributeValue</code></entry>
	                  <entry>The value of the attribute</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Relationship Attribute class</title>
	
	            <programlisting language="JAVA"><![CDATA[@Entity
	@RelationshipAttribute
	public class RelationshipObjectAttribute implements Serializable {
	  @Id @GeneratedValue private Long id;
	
	  @ManyToOne @JoinColumn
	  @Parent
	  private Relationship relationship;
	
	  @AttributeName
	  private String name;
	
	  @RelationshipValue
	  private String value;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	        </section>
	        
	        <section>
	          <title>Configuring the Partition class</title>
	          
	          <para>
	            The Partition class is used to store information about partitions, i.e. Realms and Tiers.  It should be 
	            annotated with <code>@Partition</code>.
	          </para>
	          
	          <table>
	            <title>Partition class fields</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Property</entry>
	                  <entry>Annotation</entry>
	                  <entry>Description</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry>ID</entry>
	                  <entry><code>@Identifier</code></entry>
	                  <entry>The unique identifier value for the partition</entry>
	                </row>
	                <row>
	                  <entry>Type</entry>
	                  <entry><code>@Discriminator</code></entry>
	                  <entry>The type of partition, either Realm or Tier</entry>
	                </row>
	                <row>
	                  <entry>Parent</entry>
	                  <entry><code>@Parent</code></entry>
	                  <entry>The parent partition (only used for Tiers)</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <example>
	            <title>Example Partition class</title>
	            <programlisting language="JAVA"><![CDATA[@Entity
	@Partition
	public class PartitionObject implements Serializable {
	  @Id @Identifier
	  private String id;
	
	  @Discriminator
	  private String type;
	
	  @ManyToOne 
	  @Parent
	  private PartitionObject parent;
	  
	  // getters and setters
	}]]></programlisting>
	          </example>
	        </section>
	               
	      </section>
	      
	      <section>
	        <title>LDAPIdentityStoreConfiguration</title>
	        
	        <para>
	          The LDAP identity store allows an LDAP directory server to be used to provide identity state. You can use this store in read-only or write-read mode, depending on your permissions on the server.
	        </para>
	        
	        <section>
	          <title>Configuration</title>
	          
	          <para>
	            The LDAP identity store can be configured by providing the following configuration:
			</para>
			
	          <programlisting language="JAVA"><![CDATA[IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();
	
	builder
	    .stores()
	        .ldap()
	            .baseDN("dc=jboss,dc=org")
	            .bindDN("uid=admin,ou=system")
	            .bindCredential("secret")
	            .url("ldap://localhost:10389")
	            .userDNSuffix("ou=People,dc=jboss,dc=org")
	            .roleDNSuffix("ou=Roles,dc=jboss,dc=org")
	            .groupDNSuffix("ou=Groups,dc=jboss,dc=org")
	            .supportAllFeatures();]]></programlisting>
			
			<para>
				The following table describes all configuration options:
			</para>
			
			<table>
	            <title>LDAP Configuration Options</title>
	            
	            <tgroup cols="3" align="left">
	              <thead>
	                <row>
	                  <entry>Option</entry>
	                  <entry>Description</entry>
	                  <entry>Required</entry>
	                </row>
	              </thead>
	              <tbody>
	                <row>
	                  <entry><code>baseDN</code></entry>
	                  <entry>Sets the fixed DN of the context from where identity types are stored.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>bindDN</code></entry>
	                  <entry>Sets the the DN used to bind against the ldap server. If you want to perform write operations the DN must have permissions on the agent,user,role and group contexts.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>bindCredential</code></entry>
	                  <entry>Sets the password for the bindDN.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>url</code></entry>
	                  <entry>Sets the url that should be used to connect to the server. Eg.: <![CDATA[ldap://<<server>>:389]]>.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>userDNSuffix</code></entry>
	                  <entry>Sets the fixed DN of the context where users should be read/stored from.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>agentDNSuffix</code></entry>
	                  <entry>Sets the fixed DN of the context where agents should be read/stored from. If not provided, will be used the context provided by the <code>setUserDNSuffix</code></entry>
	                  <entry>No</entry>
	                </row>
	                <row>
	                  <entry><code>roleDNSuffix</code></entry>
	                  <entry>Sets the fixed DN of the context where roles should be read/stored from.</entry>
	                  <entry>Yes</entry>
	                </row>
	                <row>
	                  <entry><code>groupDNSuffix</code></entry>
	                  <entry>Sets the fixed DN of the context where groups should be read/stored from.</entry>
	                  <entry>Yes</entry>
	                </row>
	              </tbody>
	            </tgroup>
	          </table>
	          
	          <section>
	          	<title>Mapping Groups to different contexts</title>
	          	
	          	<para>
	          		Sometimes may be useful to map a specific group to a specific context or DN. By default, all groups are stored and read from the DN provided by the <code>setGroupDNSuffix</code> method, which means that you can not have groups with the same name.
	          	</para>
	
	          	<para>
	          		The following configuration maps the group with path <emphasis>/QA Group</emphasis> to <emphasis>ou=QA,dc=jboss,dc=org</emphasis> 
	          	</para>
	          	
	          	<programlisting language="JAVA"><![CDATA[LDAPIdentityStoreConfiguration ldapStoreConfig = new LDAPIdentityStoreConfiguration();
	
	ldapStoreConfig
	  .addGroupMapping("/QA Group", "ou=QA,dc=jboss,dc=org");]]></programlisting>
				
				<para>
					With this configuration you can have groups with the same name, but with different paths.
				</para>
	
	          	<programlisting language="JAVA"><![CDATA[IdentityManager identityManager = getIdentityManager();
	Group managers = new SimpleGroup("managers");      
	
	identityManager.add(managers); // group's path is /manager 
	              
	Group qaGroup = identityManager.getGroup("QA Group");        
	Group managersQA = new SimpleGroup("managers", qaGroup);
	      
	// the QA Group is mapped to a different DN.
	Group qaManagerGroup = identityManager.add(managersQA); // group's path is /QA Group/managers]]></programlisting>			    
	          </section>			
	        </section>
	      </section>
	      
	      <section>
	        <title>FileIdentityStoreConfiguration</title>
	        
	        <para>
		  	This identity store uses the file system to persist identity state.  The configuration for this 
	          identity store provides control over where to store identity data and if the state should be preserved between initializatons. 
	        </para>
	        <para>Identity data is stored using the <emphasis>Java Serialization API</emphasis>.</para>
	
	        <section>
	          <title>Filesystem Structure</title>
	          
	          <para>
			 Identity data is stored in the filesystem using the following structure:
	          </para>
	          
		 	<programlisting language="xml"><![CDATA[${WORKING_DIR}/
	pl-idm-partitions.db
	pl-idm-relationships.db
	<<partition_name_directory>>
		pl-idm.agents.db
		pl-idm.roles.db
		pl-idm.groups.db
		pl-idm.credentials.db
	<<another_partition_directory>>
		...]]></programlisting>
		
			<para>
				By default, files are stored in the <emphasis>${java.io.tmpdir}/pl-idm</emphasis> directory. For each partition there is a corresponding directory where agents, roles groups and credentials are stored in specific files. 
			</para>
			
		  </section>
		  		
	        <section>
	          <title>Configuration</title>
	          
	          <para>
	            The file identity store can be easily configured by providing the following configuration:
			</para>
			              
	          <programlisting language="JAVA"><![CDATA[IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();
	        
	builder
	    .stores()
	        .file()
	            .preserveState(false)
	            .addRealm(Realm.DEFAULT_REALM, "Testing")
	            .addTier("Application")
	            .supportAllFeatures()
	            .supportRelationshipType(CustomRelationship.class, Authorization.class);]]></programlisting>
	
	        	<section>
	          	<title>Preserving State Between Initializations</title>
	          	
	          	<para>
	          		By default, during the initialization, the working directory is re-created. If you want to preserve state between initializations you should use the following configuration:
	          	</para>
	          	
	          	<programlisting language="JAVA"><![CDATA[builder
	.stores()
	    .file()
	        .preserveState(true) // preserve data
			.supportAllFeatures();]]></programlisting>
			</section>
			
			<section>
	          	<title>Changing the Working Directory</title>
	          	
	          	<para>
				 If you want to change the working directory, where files are stored, you can use the following configuration:            		
	          	</para>
	          	
	            	<programlisting language="JAVA"><![CDATA[builder
	.stores()
	    .file()
	        .workingDir("/tmp/pl-idm")
			.supportAllFeatures();]]></programlisting>
	     	
			</section>            
	      </section>
	    </section>
	    <section>
        	<title>Providing a Custom IdentityStore</title>
      
	        <para>
	          TODO
	        </para>
      	</section>        
      </section>      
    </section>
    
    <section>
      <title>Java EE Environments</title>
      
      <para>
        In Java EE 6.0 and higher environments, basic configuration is performed automatically with a set of sensible defaults.
        During application deployment, PicketLink will scan all deployed entity beans for any beans annotated with 
        <code>@IDMEntity</code>, and if found will use a configuration based on the <code>JPAIdentityStore</code>.
        If no entity beans have been configured for identity management and no other configuration is provided,
        a file-based identity store will be automatically configured to provide basic identity management features 
        backed by the file system.
      </para>

    </section>
    
    <section>
      <title>Using the IdentityManager</title>
      
      <para>
        The <code>org.picketlink.idm.IdentityManager</code> interface provides access to the bulk of the IDM features supported by PicketLink.
        To get access to the <code>IdentityManager</code> depends on which environment you are using. The following two
        sections describe how to access the <code>IdentityManager</code> in both Java EE and Java SE environments.
      </para>
      
      <section>
        <title>Accessing the <code>IdentityManager</code> in Java EE</title>
        
        <para>
          In a Java EE environment, the PicketLink Core module provides a producer method for <code>IdentityManager</code>, 
          so getting a reference to it is as simply as injecting it into your beans:
        </para>
      
        <programlisting language="JAVA"><![CDATA[@Inject IdentityManager identityManager;]]></programlisting>
  
      </section>
      
      <section>
        <title>Accessing the <code>IdentityManager</code> in Java SE</title>
        
        <para>
        
        </para>
      </section>
    </section>
    
    <section>
      <title>Managing Users, Groups and Roles</title>
      
      <para>
        PicketLink IDM provides a number of basic implementations of the identity model interfaces for convenience, in the
        <code>org.picketlink.idm.model</code> package.  The following sections provide examples that show these 
        implementations in action.
      </para>
  
      <section>
        <title>Managing Users</title>
        
        <para>
          The following code example demonstrates how to create a new user with the following properties:
        </para>
        
        <itemizedlist>
          <listitem>Login name - <emphasis>jsmith</emphasis></listitem>
          <listitem>First name - <emphasis>John</emphasis></listitem>
          <listitem>Last name - <emphasis>Smith</emphasis></listitem>
          <listitem>E-mail - <emphasis>jsmith@acme.com</emphasis></listitem>
        </itemizedlist> 
        
        <programlisting language="JAVA"><![CDATA[  User user = new SimpleUser("jsmith");
  user.setFirstName("John");
  user.setLastName("Smith");
  user.setEmail("jsmith@acme.com");
  identityManager.add(user);]]></programlisting>
  
        <para>
          Once the <code>User</code> is created, it's possible to look it up using its login name:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");]]></programlisting>
        
        <para>
          User properties can also be modified after the User has already been created.  The following example demonstrates how
          to change the e-mail address of the user we created above:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");
  user.setEmail("john@smith.com");
  identityManager.update(user);]]></programlisting>
  
        <para>
          Users may also be deleted.  The following example demonstrates how to delete the user previously created:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  User user = identityManager.getUser("jsmith");
  identityManager.remove("jsmith");]]></programlisting>
        
      </section>
      
      <section>
        <title>Managing Groups</title>
        
        <para>
          The following example demonstrates how to create a new group called <emphasis>employees</emphasis>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = new SimpleGroup("employees");]]></programlisting>
        
        <para>
          It is also possible to assign a parent group when creating a group.  The following example demonstrates how
          to create a new group called <emphasis>managers</emphasis>, using the <emphasis>employees</emphasis> group 
          created in the previous example as the parent group:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group managers = new SimpleGroup("managers", employees);]]></programlisting>
        
        <para>
          To lookup an existing <code>Group</code>, the <code>getGroup()</code> method may be used.  If the group name
          is unique, it can be passed as a single parameter:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");]]></programlisting>
        
        <para>
          If the group name is not unique, the parent group must be passed as the second parameter (although it can still be
          provided if the group name is unique):
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group managers = identityManager.getGroup("managers", employees);]]></programlisting>
        
        <para>
          It is also possible to modify a <code>Group</code>'s name and other properties (besides its parent) after it has
          been created.  The following example demonstrates how to disable the "employees" group we created above:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");
  employees.setEnabled(false);
  identityManager.update(employees);]]></programlisting>
        
        <para>
          To remove an existing group, we can use the <code>remove()</code> method:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Group employees = identityManager.getGroup("employees");
  identityManager.remove(employees);]]></programlisting>

      </section>
    </section>
    
    <section>
      <title>Managing Relationships</title>
      
      <para>
        Relationships are used to model <emphasis>typed associations</emphasis> between two or more identities.  All 
        concrete relationship types must implement the marker interface <code>org.picketlink.idm.model.Relationship</code>:
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/relationshipclassdiagram.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/relationshipclassdiagram.png" align="center"/>
        </imageobject>
      </mediaobject> 
                    
      <para>
        The <code>IdentityManager</code> interface provides three standard methods for managing relationships:
      </para>
      
      <programlisting language="JAVA"><![CDATA[  void add(Relationship relationship);
  void update(Relationship relationship);
  void remove(Relationship relationship);]]></programlisting>
      
      <itemizedlist>
        <listitem>
          <para>
            The <code>add()</code> method is used to create a new relationship.
          </para>
        </listitem>
        
        <listitem>
          <para>
            The <code>update()</code> method is used to update an existing relationship.
          </para>
          
          <note>
            <para>
              Please note that the identities that participate in a relationship cannot be updated themselves, 
              however the attribute values of the relationship can be updated.  If you absolutely need to modify
              the identities of a relationship, then delete the relationship and create it again.
            </para>
          </note>
        </listitem>
        
        <listitem>
          <para>
            The <code>remove()</code> method is used to remove an existing relationship.
          </para>
        </listitem>
      </itemizedlist>
      
      <note>
        <para>
          To search for existing relationships between identity objects, use the Relationship Query API described later
          in this chapter.
        </para>
      </note>
      
      <para>
        Besides the above methods, <code>IdentityManager</code> also provides a number of convenience methods for
        managing many of the built-in relationship types.  See the next section for more details.
      </para>
            
      <section>
        <title>Built In Relationship Types</title>
        
        <para>
          PicketLink provides a number of built-in relationship types, designed to address the most common requirements
          of a typical application.  The following sections describe the built-in relationships and how they are intended
          to be used.  Every built-in relationship type extends the <code>AbstractAttributedType</code> abstract class,
          which provides the basic methods for setting a unique identifier value and managing a set of attribute values:
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/abstractattributedtype.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/abstractattributedtype.png" align="center"/>
          </imageobject>
        </mediaobject> 
        
        <para>
          What this means in practical terms, is that every single relationship is assigned and can be identified by, a unique 
          identifier value.  Also, arbitrary attribute values may be set for all relationship types, which is useful if you 
          require additional metadata or any other type of information to be stored with a relationship.
        </para>
        
        <section>
          <title>Application Roles</title>
          
          <para>
            Application roles are represented by the <code>Grant</code> relationship, which is used to assign application-wide
            privileges to a <code>User</code> or <code>Agent</code>.
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/grant.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/grant.png" align="center"/>
            </imageobject>
          </mediaobject> 
          
          <para>
            The <code>IdentityManager</code> interface provides methods for directly granting a role.  Here's a simple example:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  identityManager.grantRole(bob, superuser);]]></programlisting>
          
          <para>
            The above code is equivalent to the following:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  Grant grant = new Grant(bob, superuser);
  identityManager.add(grant);]]></programlisting>
  
          <para>
            A granted role can also be revoked using the <code>revokeRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  identityManager.revokeRole(bob, superuser);]]></programlisting>
  
          <para>
            To check whether an identity has a specific role granted to them, we can use the <code>hasRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  User bob = identityManager.getUser("bob");
  Role superuser = identityManager.getRole("superuser");
  boolean isBobASuperUser = identityManager.hasRole(bob, superuser);]]></programlisting>
        </section>
        
        <section>
          <title>Groups and Group Roles</title>
          
          <para>
            The <code>GroupMembership</code> and <code>GroupRole</code> relationships are used to represent a user's membership
            within a <code>Group</code>, and a user's role for a group, respectively.
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/grouprole.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/grouprole.png" align="center"/>
            </imageobject>
          </mediaobject>  
          
          <note>
            <para>
              While the <code>GroupRole</code> relationship type extends <code>GroupMembership</code>, it does 
              <emphasis>not</emphasis> mean that a member of a <code>GroupRole</code> automatically receives 
              <code>GroupMembership</code> membership also - these are two distinct relationship types with
              different semantics.
            </para>
          </note>                              
          
          <para>
            A <code>Group</code> is typically used to form logical collections of users.  Within an organisation, groups are 
            often used to mirror the organisation's structure.  For example, a corporate structure might consist of a sales
            department, administration, management, etc.  This structure can be modelled in PicketLink by creating corresponding
            groups such as <emphasis>sales</emphasis>, <emphasis>administration</emphasis>, and so forth.  Users (who would represent 
            the employees in a corporate structure) may then be assigned group memberships corresponding to their place within 
            the company's organisational structure.  For example, an employee who works in the sales department 
            may be assigned to the <emphasis>sales</emphasis> group.
            Specific application privileges can then be blanket assigned to the <emphasis>sales</emphasis> group, and anyone who 
            is a member of the group is free to access the application's features that require those privileges.
          </para>
         
          <para>
            The <code>GroupRole</code> relationship type should be used when it is intended for an identity to perform a specific
            role for a group, but not be an actual member of the group itself.  For example, an administrator of a group of doctors
            may not be a doctor themselves, but have an administrative role to perform for that group.  If the intent is for 
            an individual identity to both be a member of a group <emphasis>and</emphasis> have an assigned role in that group 
            also, then the identity should have both <code>GroupRole</code> and <code>GroupMembership</code> relationships for 
            that group.
          </para>          
          
          <para>
            Let's start by looking at a simple example - we'll begin by making the assumption that our organization is
            structured in the following way:
          </para>
          
          <mediaobject>
            <imageobject role="fo">
              <imagedata fileref="diagrams/example_group_structure.png" align="center" scalefit="1"/>
            </imageobject>
            <imageobject role="html">
              <imagedata fileref="diagrams/example_group_structure.png" align="center"/>
            </imageobject>
          </mediaobject>            
          
          <para>
            The following code demonstrates how we would create the hypothetical <emphasis>Sales</emphasis> group which 
            is displayed at the head of the above organisational chart:
          </para>
          
          <programlisting language="JAVA"><![CDATA[  Group sales = new SimpleGroup("Sales");
  identityManager.add(sales);]]></programlisting>
  
          <para>
            We can then proceed to create its subgroups:
          </para>
          
          <programlisting language="JAVA"><![CDATA[identityManager.add(new SimpleGroup("North America", sales);
identityManager.add(new SimpleGroup("EMEA", sales);
identityManager.add(new SimpleGroup("Asia", sales);
// and so forth]]></programlisting>          

          <para>
            The second parameter of the <code>SimpleGroup()</code> constructor is used to specify the group's parent group.
            This allows us to create a hierarchical group structure, which can be used to mirror either a simple or complex 
            personnel structure of an organisation.  Let's now take a look at how we assign users to these groups.
          </para>
          
          <para>
            The following code demonstrates how to assign an <emphasis>administrator</emphasis> group role for the
            <emphasis>Northeast</emphasis> sales group to user <emphasis>jsmith</emphasis>.  The 
            <emphasis>administrator</emphasis> group role may be used to grant certain users the privilege to modify
            permissions and roles for that group:
          </para>
          
          <programlisting language="JAVA"><![CDATA[Role admin = identityManager.getRole("administrator");
User user = identityManager.getUser("jsmith");
Group group = identityManager.getGroup("Northeast");
identityManager.grantGroupRole(user, admin, group);]]></programlisting>

          <para>
            A group role can be revoked using the <code>revokeGroupRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[identityManager.revokeGroupRole(user, admin, group);]]></programlisting>
  
          <para>
            To test whether a user has a particular group role, you can use the <code>hasGroupRole()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[boolean isUserAGroupAdmin = identityManager.hasGroupRole(user, admin, group);]]></programlisting> 

          <para>
            Next, let's look at some examples of how to work with simple group memberships. 
            The following code demonstrates how we assign sales staff <emphasis>rbrown</emphasis> to the 
            <emphasis>Northeast</emphasis> sales group:
          </para>
          
          <programlisting language="JAVA"><![CDATA[User user = identityManager.getUser("rbrown");
Group group = identityManager.getGroup("Northeast");
identityManager.addToGroup(user, group);]]></programlisting>          
          
          <para>
            A <code>User</code> may also be a member of more than one <code>Group</code>; there are no built-in limitations on 
            the number of groups that a <code>User</code> may be a member of.  
          </para>
          
          <para>
            We can use the <code>removeFromGroup()</code> method to remove the same user from the group:
          </para>
          
          <programlisting language="JAVA"><![CDATA[identityManager.removeFromGroup(user, group);]]></programlisting>
  
          <para>
            To check whether a user is the member of a group we can use the <code>isMember()</code> method:
          </para>
          
          <programlisting language="JAVA"><![CDATA[boolean isUserAMember = identityManager.isMember(user, group);]]></programlisting>
 
          <para>
            Relationships can also be created via the <code>add()</code> method.  The following code is equivalent
            to assigning a group role via the <code>grantGroupRole()</code> method shown above:
          </para>
          
          <programlisting language="JAVA"><![CDATA[Role admin = identityManager.getRole("administrator");
User user = identityManager.getUser("jsmith");
Group group = identityManager.getGroup("Northeast");
GroupRole groupRole = new GroupRole(user, group, admin);
identityManager.add(groupRole);]]></programlisting>
        </section>
        
      </section>
      
      <section>
        <title>Creating Custom Relationships</title>
        
        <para>
          One of the strengths of PicketLink is its ability to support custom relationship types.  This extensibility allows you, the
          developer to create specific relationship types between two or more identities to address the domain-specific requirements
          of your own application.  
        </para>
        
        <note>
          <para>
            Please note that custom relationship types are not supported by all <code>IdentityStore</code> implementations - 
            see the Identity Store section above for more information.
          </para>
        </note>
        
        <para>
          To create a custom relationship type, we start by creating a new class that implements the <code>Relationship</code> interface.
          To save time, we also extend the <code>AbstractAttributedType</code> abstract class which takes care of the identifier and
          attribute management methods for us:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  public class Authorization extends AbstractAttributedType implements Relationship {
        
  }]]></programlisting>
        
        <para>
          The next step is to define which identities participate in the relationship.  Once we create our identity property methods,
          we also need to annotate them with the <code>org.picketlink.idm.model.annotation.RelationshipIdentity</code> annotation.  
          This is done by creating a property for each identity type.
        </para>
        
        <programlisting language="JAVA"><![CDATA[  private User user;
  private Agent application;
  
  @RelationshipIdentity
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  @RelationshipIdentity
  public Agent getApplication() {
    return application;
  }
  
  public void setApplication(Agent application) {
    this.application = application;
  }]]></programlisting>
          
          <code>
            We can also define some attribute properties, using the <code>@RelationshipAttribute</code> annotation:
          </code>
          
          <programlisting language="JAVA"><![CDATA[  private String accessToken;
  
  @RelationshipAttribute
  public String getAccessToken() {
    return accessToken;
  }
  
  public void setAccessToken(String accessToken) {
    this.accessToken = accessToken;
  }]]></programlisting>
      </section>
      
    </section>
    
    <section>
      <title>Authentication</title>
      
      <note>
        <para>
          While the IDM module of PicketLink provides authentication features, for common use cases involving standard username and
          password based authentication in a Java EE environment, the PicketLink core module provides a more streamlined method
          of authentication.  Please refer to the authentication chapter of this documentation for more information.
        </para>
      </note>
      
      <para>
        PicketLink IDM provides an authentication subsystem that allows user credentials to be validated thereby confirming
        that an authenticating user is who they claim to be.  The <code>IdentityManager</code> interface provides a single
        method for performing credential validation, as follows:
      </para>
      
      <programlisting language="JAVA"><![CDATA[void validateCredentials(Credentials credentials);]]></programlisting>
      
      <para>
        The <code>validateCredentials()</code> method accepts a single <code>Credentials</code> parameter, which should
        contain all of the state required to determine who is attempting to authenticate, and the credential (such as a
        password, certificate, etc) that they are authenticating with.  Let's take a look at the <code>Credentials</code>
        interface:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface Credentials {
    public enum Status {
        UNVALIDATED, IN_PROGRESS, INVALID, VALID, EXPIRED
    };

   Agent getValidatedAgent();
   
   Status getStatus();
   
   void invalidate();
}]]></programlisting>

      <itemizedlist>
        <listitem>
          <para>
            The <code>Status</code> enum defines the following values, which reflect the various credential states:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <code>UNVALIDATED</code> - The credential is yet to be validated.
              </para>
            </listitem>
            <listitem>
              <para>
                <code>IN_PROGRESS</code> - The credential is in the process of being validated.
              </para>
            </listitem>
            <listitem>
              <para>
                <code>INVALID</code> - The credential has been validated unsuccessfully
              </para>
            </listitem>
            <listitem>
              <para>
                <code>VALID</code> - The credential has been validated successfully
              </para>
            </listitem>
            <listitem>
              <para>
                <code>EXPIRED</code> - The credential has expired
              </para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>
            <code>getValidatedAgent()</code> - If the credential was successfully validated, this method returns the
            <code>Agent</code> object representing the validated user.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>getStatus()</code> - Returns the current status of the credential, i.e. one of the above enum values.
          </para>
        </listitem>
        <listitem>
          <para>
            <code>invalidate()</code> - Invalidate the credential.  Implementations of <code>Credential</code> should use
            this method to clean up internal credential state.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Let's take a look at a concrete example - <code>UsernamePasswordCredentials</code> is a <code>Credentials</code>
        implementation that supports traditional username/password-based authentication:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public class UsernamePasswordCredentials extends AbstractBaseCredentials {

    private String username;

    private Password password;

    public UsernamePasswordCredentials() { }

    public UsernamePasswordCredentials(String userName, Password password) {
        this.username = userName;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public UsernamePasswordCredentials setUsername(String username) {
        this.username = username;
        return this;
    }

    public Password getPassword() {
        return password;
    }

    public UsernamePasswordCredentials setPassword(Password password) {
        this.password = password;
        return this;
    }

    @Override
    public void invalidate() {
        setStatus(Status.INVALID);
        password.clear();
    }
}]]></programlisting>

      <para>
        The first thing we may notice about the above code is that the <code>UsernamePasswordCredentials</code> class extends
        <code>AbstractBaseCredentials</code>.  This abstract base class implements the basic functionality required by the 
        <code>Credentials</code> interface.  Next, we can see that two fields are defined; <code>username</code> and <code>password</code>.
        These fields are used to hold the username and password state, and can be set either via the constructor,
        or by their associated setter methods.  Finally, we can also see that the <code>invalidate()</code> method sets the status to
        <code>INVALID</code>, and also clears the password value.
      </para>
      
      <para>
        Let's take a look at an example of the above classes in action.  The following code demonstrates how we would authenticate
        a user with a username of "john" and a password of "abcde":
      </para>
      
      <programlisting language="JAVA"><![CDATA[Credentials creds = new UsernamePasswordCredentials("john",
    new Password("abcde"));
identityManager.validate(creds);
if (Status.VALID.equals(creds.getStatus())) {
  // authentication was successful
}]]></programlisting>
    
      <para>
        We can also test if the credentials that were provided have expired (if an expiry date was set).  In this case we might
        redirect the user to a form where they can enter a new password.
      </para>
      
      <programlisting language="JAVA"><![CDATA[Credentials creds = new UsernamePasswordCredentials("john",
    new Password("abcde"));
identityManager.validate(creds);
if (Status.EXPIRED.equals(creds.getStatus())) {
  // password has expired, redirect the user to a password change screen
}]]></programlisting>
      
    </section>

    <section>
      <title>Managing Credentials</title>
      
      <para>
        Updating user credentials is even easier than validating them.  The <code>IdentityManager</code> interface provides the following
        two methods for updating credentials:
      </para>
      
      <programlisting language="JAVA"><![CDATA[void updateCredential(Agent agent, Object credential);
void updateCredential(Agent agent, Object credential, Date effectiveDate, Date expiryDate);]]></programlisting>

      <para>
        Both of these methods essentially do the same thing; they update a credential value for a specified <code>Agent</code>
        (or <code>User</code>).  The second overloaded method however also accepts <code>effectiveDate</code> and <code>expiryDate</code> 
        parameters, which allow some temporal control over when the credential will be valid.  Use cases for this feature 
        include implementing a strict password expiry policy (by providing an expiry date), or creating a new account that might not 
        become active until a date in the future (by providing an effective date).  Invoking the first overloaded method will
        store the credential with an effective date of the current date and time, and no expiry date.
      </para>

      <note>      
        <para>
          One important point to note is that the <code>credential</code> parameter is of type <code>java.lang.Object</code>.  Since
          credentials can come in all shapes and sizes (and may even be defined by third party libraries), there is no common base 
          interface for credential implementations to extend.  To support this type of flexibility in an extensible way, PicketLink 
          provides an SPI that allows custom credential handlers to be configured that override or extend the default credential 
          handling logic.  Please see the next section for more information on how this SPI may be used.
        </para>
      </note>
      
      <para>
        PicketLink provides built-in support for the following credential types:
      </para>
      
      <warning>
        <para>
          Not all built-in <code>IdentityStore</code> implementations support all credential types.  For example, since the
          <code>LDAPIdentityStore</code> is backed by an LDAP directory server, only password credentials are supported.  The
          following table lists the built-in <code>IdentityStore</code> implementations that support each credential type.
        </para>
      </warning>
      
      <table>
        <title>Built-in credential types</title>
        
        <tgroup cols="3" align="left">
          <thead>
            <row>
              <entry>Credential type</entry>
              <entry>Description</entry>
              <entry>Supported by</entry>
            </row>
          </thead>
          <tbody valign="top">
            <row>
              <entry><code>org.picketlink.idm.credential.Digest</code></entry>
              <entry>Used for digest-based authentication</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>
              </entry>
            </row>
            <row>
              <entry><code>org.picketlink.idm.credential.Password</code></entry>
              <entry>A standard text-based password</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>
                <code>LDAPIdentityStore</code>
              </entry>
            </row>
            <row>
              <entry><code>java.security.cert.X509Certificate</code></entry>
              <entry>Used for X509 certificate based authentication</entry>
              <entry>
                <code>JPAIdentityStore</code>
                <code>FileBasedIdentityStore</code>             
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
           
      <para>
        Let's take a look at a couple of examples.  Here's some code demonstrating how a password can be assigned
        to user "jsmith":
      </para>
      
      <programlisting language="JAVA"><![CDATA[User user = identityManager.getUser("jsmith");
identityManager.updateCredential(user, new Password("abcd1234"));]]></programlisting>

      <para>
        This example creates a digest and assigns it to user "jdoe":
      </para>
      
      <programlisting language="JAVA"><![CDATA[User user = identityManager.getUser("jdoe");
Digest digest = new Digest();
digest.setRealm("default");
digest.setUsername(user.getLoginName());
digest.setPassword("abcd1234");        
identityManager.updateCredential(user, digest);]]></programlisting>
      
    </section>
    
    <section>
      <title>Credential Handlers</title>
      
      <para>
        For <code>IdentityStore</code> implementations that support multiple credential types, PicketLink provides
        an optional SPI to allow the default credential handling logic to be easily customized and extended. To get
        a better picture of the overall workings of the Credential Handler SPI, let's take a look at the sequence
        of events during the credential validation process when validating a username and password against
        <code>JPAIdentityStore</code>:
      </para>
      
      <mediaobject>
        <imageobject role="fo">
          <imagedata fileref="diagrams/username_password_validation.png" align="center" scalefit="1"/>
        </imageobject>
        <imageobject role="html">
          <imagedata fileref="diagrams/username_password_validation.png" align="center"/>
        </imageobject>
      </mediaobject>       
      
     <itemizedlist>
        <listitem>
          <para>
            <emphasis>1</emphasis> -
            The user (or some other code) first invokes the <code>validateCredentials()</code> method on <code>IdentityManager</code>,
            passing in the <code>Credentials</code> instance to validate.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>1.1</emphasis> -
            After looking up the correct <code>IdentityStore</code> (i.e. the one that has been configured to validate credentials)
            the <code>IdentityManager</code> invokes the store's <code>validateCredentials()</code> method, passing in the
            <code>SecurityContext</code> and the credentials to validate.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis>1.1.1</emphasis> - 
            In <code>JPAIdentityStore</code>'s implementation of the <code>validateCredentials()</code> method, the 
            <code>SecurityContext</code> is used to look up the <code>CredentialHandler</code> implementation that has been 
            configured to process validation requests for usernames and passwords, which is then stored in a local variable
            called <code>handler</code>.
          </para>
        </listitem>
        <listitem>                
          <para>
            <emphasis>1.1.2</emphasis> -
            The <code>validate()</code> method is invoked on the <code>CredentialHandler</code>, passing in the security context,
            the credentials value and a reference back to the identity store.  The reference to the identity store is important
            as the credential handler may require it to invoke certain methods upon the store to validate the credentials.
          </para>
        </listitem>
      </itemizedlist>           
      
      <para>
        The <code>CredentialHandler</code> interface declares three methods, as follows:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface CredentialHandler {
    void setup(IdentityStore<?> identityStore);

    void validate(SecurityContext context, Credentials credentials, 
                  IdentityStore<?> identityStore);

    void update(SecurityContext context, Agent agent, Object credential, 
                IdentityStore<?> identityStore, Date effectiveDate, Date expiryDate);

}]]></programlisting>

      <para>
        The <code>setup()</code> method is called once, when the <code>CredentialHandler</code> instance is first created. 
        Credential handler instantiation is controlled by the <code>CredentialHandlerFactory</code>, which creates a single
        instance of each <code>CredentialHandler</code> implementation to service all credential requests for that handler.
        Each <code>CredentialHandler</code> implementation must declare the types of credentials that it is capable of supporting,
        which is done by annotating the implementation class with the <code>@SupportsCredentials</code> annotation like so:
      </para>
    
      <programlisting language="JAVA"><![CDATA[@SupportsCredentials({ UsernamePasswordCredentials.class, Password.class })
public class PasswordCredentialHandler implements CredentialHandler {]]></programlisting>
  
      <para>
        Since the <code>validate()</code> and <code>update()</code> methods receive different parameter types (<code>validate()</code>
        takes a <code>Credentials</code> parameter value while <code>update()</code> takes an <code>Object</code> that represents
        a single credential value), the <code>@SupportsCredentials</code> annotation must contain a complete list of all types supported
        by that handler.
      </para>
      
      <para>
        Similarly, if the <code>IdentityStore</code> implementation makes use of the credential handler SPI then it also must declare
        which credential handlers support that identity store.  This is done using the <code>@CredentialHandlers</code> annotation; 
        for example, the following code shows how <code>JPAIdentityStore</code> is configured to be capable of handling credential
        requests for usernames and passwords, X509 certificates and digest-based authentication:
      </para>
      
      <programlisting language="JAVA"><![CDATA[@CredentialHandlers({ PasswordCredentialHandler.class,
          X509CertificateCredentialHandler.class, DigestCredentialHandler.class })
public class JPAIdentityStore implements IdentityStore<JPAIdentityStoreConfiguration>, 
                                         CredentialStore {]]></programlisting>
                                         
      <section>
        <title>The CredentialStore interface</title>
        
        <para>
          For <code>IdentityStore</code> implementations that support multiple credential types (such as <code>JPAIdentityStore</code>
          and <code>FileBasedIdentityStore</code>), the implementation may choose to also implement the <code>CredentialStore</code>
          interface to simplify the interaction between the <code>CredentialHandler</code> and the <code>IdentityStore</code>.  The
          <code>CredentialStore</code> interface declares methods for storing and retrieving credential values within an identity
          store, as follows:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public interface CredentialStore {
   void storeCredential(SecurityContext context, Agent agent, 
                        CredentialStorage storage);
   <T extends CredentialStorage> T retrieveCurrentCredential(SecurityContext context, 
                                                 Agent agent, Class<T> storageClass);
   <T extends CredentialStorage> List<T> retrieveCredentials(SecurityContext context, 
                                                 Agent agent, Class<T> storageClass);
}]]></programlisting>

        <para>
          The <code>CredentialStorage</code> interface is quite simple and only declares two methods, <code>getEffectiveDate()</code>
          and <code>getExpiryDate()</code>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public interface CredentialStorage {
   @Stored Date getEffectiveDate();
   @Stored Date getExpiryDate();
}]]></programlisting>

        <para>
          The most important thing to note above is the usage of the <code>@Stored</code> annotation.  This annotation is used to
          mark the properties of the <code>CredentialStorage</code> implementation that should be persisted.  The only requirement
          for any property values that are marked as <code>@Stored</code> is that they are serializable (i.e. they implement the
          <code>java.io.Serializable</code> interface).  The <code>@Stored</code> annotation may be placed on either the getter 
          method or the field variable itself.  Here's an example of one of a <code>CredentialStorage</code> implementation that
          is built into PicketLink - <code>EncodedPasswordStorage</code> is used to store a password hash and salt value:
        </para>
        
        <programlisting language="JAVA"><![CDATA[public class EncodedPasswordStorage implements CredentialStorage {

    private Date effectiveDate;
    private Date expiryDate;
    private String encodedHash;
    private String salt;

    @Override @Stored
    public Date getEffectiveDate() {
        return effectiveDate;
    }

    public void setEffectiveDate(Date effectiveDate) {
        this.effectiveDate = effectiveDate;
    }

    @Override @Stored
    public Date getExpiryDate() {
        return expiryDate;
    }

    public void setExpiryDate(Date expiryDate) {
        this.expiryDate = expiryDate;
    }

    @Stored
    public String getEncodedHash() {
        return encodedHash;
    }

    public void setEncodedHash(String encodedHash) {
        this.encodedHash = encodedHash;
    }

    @Stored
    public String getSalt() {
        return this.salt;
    }

    public void setSalt(String salt) {
        this.salt = salt;
    }

}]]></programlisting>
      
      </section>

    </section>
    
    <section>
      <title>Built-in Credential Handlers</title>
     
      <para>
        This section describes each of the built-in credential handlers, and any configuration parameters that may be set for them.
        Specific credential handler options can be set when creating a new <code>IdentityConfiguration</code>.  Configured options 
        are always specific to a particular identity store configuration, allowing different options to be specified between two or
        more identity stores.  The <code>IdentityStoreConfiguration</code> interface provides a method called
        <code>getCredentialHandlersConfig()</code> that provides access to a <code>Map</code> which allows configuration options
        to be set for the identity store's credential handlers:
      </para>
      
      <programlisting language="JAVA"><![CDATA[public interface IdentityStoreConfiguration {
    Map<String, Object> getCredentialHandlerProperties();
}]]></programlisting>

      <para>
        To gain access to the <code>IdentityStoreConfiguration</code> object before PicketLink is initialized, there are a couple of
        options.  The first option is to provide an <code>IdentityConfiguration</code> object itself via a producer method.
      </para>
      
      <programlisting language="JAVA"><![CDATA[
      
      ]]></programlisting>

      <section>
        <title></title>
        
        <para>
        
        </para>
      </section>

    </section>
    
    <section>
      <title>Advanced Topics</title>
      
      <section>
        <title>Multi Realm Support</title>
        
        <para>
          PicketLink has been designed from the ground up to support a system of <emphasis>partitioning</emphasis>, allowing the
          users, groups and roles of an application to be divided into <emphasis>Realms</emphasis> and <emphasis>Tiers</emphasis>.
        </para>
             
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/realm_tier.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/realm_tier.png" align="center"/>
          </imageobject>
        </mediaobject>   
        
        <para>
          A <emphasis>Realm</emphasis> is used to define a discrete set of users, groups and roles.  A typical use case for realms
          is the segregation of corporate user accounts within a multi-tenant application, although it is not limited this use case only.
          As all identity management operations must be performed within the context of an <emphasis>active partition</emphasis>, 
          PicketLink defines the concept of a <emphasis>default realm</emphasis> which becomes the active partition if no other 
          partition has been specified.
        </para>
        
        <para>
          A <emphasis>Tier</emphasis> is a more restrictive type of partition than a realm, as it only allows groups and roles to be 
          defined (but not users).  A Tier may be used to define a set of application-specific groups and roles, which may then be 
          assigned to groups within the same Tier, or to users and groups within a separate Realm.
        </para>
        
        <para>
          In terms of API, both the <code>Realm</code> and <code>Tier</code> classes implement the <code>Partition</code> interface,
          as shown in the following class diagram:
        </para>
        
        <mediaobject>
          <imageobject role="fo">
            <imagedata fileref="diagrams/partition.png" align="center" scalefit="1"/>
          </imageobject>
          <imageobject role="html">
            <imagedata fileref="diagrams/partition.png" align="center"/>
          </imageobject>
        </mediaobject> 
        
        <para>
          Selecting the specific partition that the identity management operations are performed in is controlled by specifying 
          the partition when creating the <code>IdentityManager</code> via the <code>IdentityManagerFactory</code>'s overloaded 
          <code>createIdentityManager()</code> methods:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  IdentityManager createIdentityManager();
    IdentityManager createIdentityManager(Partition partition);]]></programlisting>
    
        <para>
          The first method (without parameters) will create an <code>IdentityManager</code> instance for the default realm.  The
          second parameter allows a <code>Partition</code> object to be specified.  Once the <code>IdentityManager</code> has been
          created, any identity management methods invoked on it will be performed within the selected partition.  To look up the 
          partition object, the <code>IdentityManagerFactory</code> provides two additional methods:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Realm getRealm(String id);
    Tier getTier(String id);]]></programlisting>
    
        <para>
          Here's an example demonstrating how a new user called "bob" is created in a realm called <emphasis>acme</emphasis>:
        </para>
        
        <programlisting language="JAVA"><![CDATA[  Realm acme = identityManagerFactory.getRealm("acme");
    IdentityManager im = identityManagerFactory.createIdentityManager(acme);
    im.add(new SimpleUser("bob"));]]></programlisting>
        
      </section>      
      
    </section>

</chapter>
